<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>フリックボール - ステージチャレンジ</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#cfefff;}
  canvas{display:block;background:linear-gradient(#dff,#9ef);touch-action:none;}
  #ui{position:fixed;top:10px;right:10px;padding:10px;background:#fff;border-radius:8px;box-shadow:0 0 8px rgba(0,0,0,0.2);font-family:sans-serif;}
  #ui h3{margin:0 0 6px;font-size:14px;}
  #ui label{display:block;font-size:12px;margin-top:6px;}
  #ui input{width:160px;}
  #ui button{margin-top:8px;width:100%;padding:6px;}
  #counter{margin-top:6px;font-size:13px;font-weight:bold;}
  #status{margin-top:6px;font-size:14px;font-weight:bold;text-align:center;}
</style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="ui">
    <h3>フリックボール</h3>
    <div id="counter">フリック回数：0</div>
    <label>重力: <span id="gravVal">1200</span></label>
    <input id="grav" type="range" min="200" max="3000" value="1200">
    <label>速度倍率: <span id="velVal">1.0</span></label>
    <input id="vel" type="range" min="0.2" max="3.0" step="0.1" value="1.0">
    <button id="reset">リセット</button>
    <div id="status"></div>
  </div>

<script>
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
canvas.width=900;canvas.height=600;

// --- パラメータ ---
let gravity=1200,velocityMultiplier=1.0;
const WORLD_WIDTH=2000; // ステージ横幅

const CONFIG={
  ballRadius:18,
  startPos:{x:80,y:550},
  OBSTACLES:[
    {x:300,y:500,w:200,h:20},
    {x:700,y:420,w:180,h:20},
    {x:1100,y:360,w:220,h:20},
    {x:1400,y:480,w:260,h:20}
  ],
  GOAL:{x:1850,y:500,w:100,h:60},
  ENEMIES:[
    {x:500,y:480,w:40,h:40,range:100,speed:80,dir:1},
    {x:1200,y:340,w:40,h:40,range:120,speed:100,dir:-1}
  ]
};

// --- 状態 ---
const state={
  ball:{x:CONFIG.startPos.x,y:CONFIG.startPos.y,vx:0,vy:0,r:CONFIG.ballRadius},
  obstacles:JSON.parse(JSON.stringify(CONFIG.OBSTACLES)),
  goal:{...CONFIG.GOAL},
  enemies:JSON.parse(JSON.stringify(CONFIG.ENEMIES)),
  launched:false,finished:false,gameover:false,lastTime:performance.now(),
  shots:0
};

// --- 入力 ---
let pointer={down:false,sx:0,sy:0,st:0};
function getPointerPos(e){
  if(e.touches&&e.touches[0])return{x:e.touches[0].clientX,y:e.touches[0].clientY};
  if(e.clientX!==undefined)return{x:e.clientX,y:e.clientY};
  return null;
}
function pageToCanvas(pos){
  const rect=canvas.getBoundingClientRect();
  return{x:(pos.x-rect.left)*(canvas.width/rect.width),y:(pos.y-rect.top)*(canvas.height/rect.height)};
}
function pointerDown(e){
  if(state.finished||state.gameover)return;
  const p0=getPointerPos(e);if(!p0)return;
  const p=pageToCanvas(p0);
  pointer.down=true;pointer.sx=p.x;pointer.sy=p.y;pointer.st=performance.now();
}
function pointerUp(e){
  if(!pointer.down)return;
  const p0=getPointerPos(e);if(!p0){pointer.down=false;return;}
  const p=pageToCanvas(p0);
  const dt=(performance.now()-pointer.st)/1000;
  if(dt>0){
    const dx=p.x-pointer.sx,dy=p.y-pointer.sy;
    state.ball.vx=(dx/dt)*velocityMultiplier*0.8;
    state.ball.vy=(dy/dt)*velocityMultiplier*0.8;
    state.launched=true;
    state.shots++;
    document.getElementById('counter').textContent='フリック回数：'+state.shots;
  }
  pointer.down=false;
}
canvas.addEventListener('mousedown',pointerDown);
window.addEventListener('mouseup',pointerUp);
canvas.addEventListener('touchstart',pointerDown,{passive:false});
canvas.addEventListener('touchend',pointerUp,{passive:false});

// --- 衝突判定 ---
function circleRectCollision(ball,rect){
  const cx=Math.max(rect.x,Math.min(ball.x,rect.x+rect.w));
  const cy=Math.max(rect.y,Math.min(ball.y,rect.y+rect.h));
  const dx=ball.x-cx,dy=ball.y-cy;
  const dist2=dx*dx+dy*dy;
  if(dist2<ball.r*ball.r){
    const dist=Math.sqrt(dist2)||0.0001;
    const nx=dx/dist,ny=dy/dist;
    const penetration=ball.r-dist;
    return{hit:true,nx,ny,penetration};
  }
  return{hit:false};
}
function resolveCollision(ball,rect){
  const col=circleRectCollision(ball,rect);
  if(!col.hit)return;
  ball.x+=col.nx*col.penetration;
  ball.y+=col.ny*col.penetration;
  const speed=ball.vx*col.nx+ball.vy*col.ny;
  const restitution=0.4;
  const impulse=-(1+restitution)*speed;
  ball.vx+=impulse*col.nx;
  ball.vy+=impulse*col.ny;
}
function checkGoal(b,g){return(b.x>g.x&&b.x<g.x+g.w&&b.y>g.y&&b.y<g.y+g.h);}
function checkEnemyHit(b,en){
  const cx=Math.max(en.x,Math.min(b.x,en.x+en.w));
  const cy=Math.max(en.y,Math.min(b.y,en.y+en.h));
  const dx=b.x-cx,dy=b.y-cy;
  return(dx*dx+dy*dy<b.r*b.r);
}

// --- 描画 ---
function draw(cameraX){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const offset=-cameraX;

  // 背景
  ctx.fillStyle='#bdefff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // 障害物
  ctx.fillStyle='#8a5a3b';
  for(const o of state.obstacles) ctx.fillRect(o.x+offset,o.y,o.w,o.h);

  // 敵
  for(const en of state.enemies){
    ctx.fillStyle='#e74c3c';
    ctx.fillRect(en.x+offset,en.y,en.w,en.h);
  }

  // ゴール
  ctx.fillStyle=state.finished?'#2ecc71':'#4caf50';
  ctx.fillRect(state.goal.x+offset,state.goal.y,state.goal.w,state.goal.h);
  ctx.fillStyle='#fff';
  ctx.font='18px sans-serif';ctx.textAlign='center';
  ctx.fillText('GOAL',state.goal.x+offset+state.goal.w/2,state.goal.y+state.goal.h/2+6);

  // ボール
  const b=state.ball;
  ctx.beginPath();
  ctx.arc(b.x+offset,b.y,b.r,0,Math.PI*2);
  ctx.fillStyle='#fff';ctx.fill();ctx.strokeStyle='#0003';ctx.stroke();

  // 状態表示
  const status=document.getElementById('status');
  if(state.finished){status.textContent='CLEAR!!';status.style.color='green';}
  else if(state.gameover){status.textContent='GAME OVER';status.style.color='red';}
  else{status.textContent='';}
}

// --- 更新 ---
function step(now){
  const dt=Math.min((now-state.lastTime)/1000,1/15);
  state.lastTime=now;
  const b=state.ball;
  if(state.launched&&!state.finished&&!state.gameover){
    b.vy+=gravity*dt;
    b.x+=b.vx*dt; b.y+=b.vy*dt;
    if(b.x-b.r<0){b.x=b.r;b.vx=-b.vx*0.6;}
    if(b.x+b.r>WORLD_WIDTH){b.x=WORLD_WIDTH-b.r;b.vx=-b.vx*0.6;}
    if(b.y-b.r<0){b.y=b.r;b.vy=-b.vy*0.6;}
    if(b.y+b.r>canvas.height){b.y=canvas.height-b.r;b.vy=-b.vy*0.5;}

    for(const o of state.obstacles)resolveCollision(b,o);

    // 敵の移動と当たり判定
    for(const en of state.enemies){
      en.x+=en.dir*en.speed*dt;
      if(en.x>en.startX+en.range||en.x<en.startX-en.range)en.dir*=-1;
      if(checkEnemyHit(b,en)){state.gameover=true;}
    }

    b.vx*=0.999;b.vy*=0.999;
    if(checkGoal(b,state.goal)){state.finished=true;state.launched=false;}
  }

  // カメラ位置（ボール中心）
  const cameraX=Math.max(0,Math.min(b.x-canvas.width/2,WORLD_WIDTH-canvas.width));
  draw(cameraX);
  requestAnimationFrame(step);
}

// --- 初期化 ---
for(const en of state.enemies)en.startX=en.x;
requestAnimationFrame(step);

// --- UI ---
document.getElementById('grav').oninput=e=>{
  gravity=+e.target.value;
  document.getElementById('gravVal').textContent=gravity;
};
document.getElementById('vel').oninput=e=>{
  velocityMultiplier=+e.target.value;
  document.getElementById('velVal').textContent=velocityMultiplier.toFixed(1);
};
document.getElementById('reset').onclick=()=>{
  state.ball={x:CONFIG.startPos.x,y:CONFIG.startPos.y,vx:0,vy:0,r:CONFIG.ballRadius};
  state.finished=false;state.gameover=false;state.launched=false;
  state.shots=0;
  document.getElementById('counter').textContent='フリック回数：0';
  state.enemies=JSON.parse(JSON.stringify(CONFIG.ENEMIES));
  for(const en of state.enemies)en.startX=en.x;
};
</script>
</body>
</html>
