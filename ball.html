<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>フリックボール - ステージチャレンジ（スマホ対応）</title>
<style>
  html,body{
    height:100%;
    margin:0;
    overflow:hidden;
    background:#cfefff;
    touch-action:none; /* スマホでのスクロール・ズームを禁止 */
  }
  canvas{
    display:block;
    background:linear-gradient(#dff,#9ef);
    touch-action:none;
  }
  #ui{
    position:fixed;
    top:10px;
    right:10px;
    padding:10px;
    background:#fff;
    border-radius:8px;
    box-shadow:0 0 8px rgba(0,0,0,0.2);
    font-family:sans-serif;
  }
  #ui h3{margin:0 0 6px;font-size:14px;}
  #ui label{display:block;font-size:12px;margin-top:6px;}
  #ui input{width:160px;}
  #ui button{margin-top:8px;width:100%;padding:6px;}
  #counter,#stageLabel{margin-top:6px;font-size:13px;font-weight:bold;}
  #status{margin-top:6px;font-size:14px;font-weight:bold;text-align:center;}
</style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="ui">
    <h3>フリックボール</h3>
    <div id="stageLabel">ステージ：1</div>
    <div id="counter">フリック回数：0</div>
    <label>重力: <span id="gravVal">1200</span></label>
    <input id="grav" type="range" min="200" max="3000" value="1200">
    <label>速度倍率: <span id="velVal">1.0</span></label>
    <input id="vel" type="range" min="0.2" max="3.0" step="0.1" value="1.0">
    <button id="reset">リセット</button>
    <button id="next">次のステージ</button>
    <div id="status"></div>
  </div>

<script>
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
canvas.width=900;
canvas.height=600;

// ----- 物理パラメータ -----
let gravity=1200,velocityMultiplier=1.0;
const WORLD_WIDTH=2000;
const groundFriction=0.85;
const airResistance=0.995;

// ----- ステージデータ -----
const STAGES=[
  {
    OBSTACLES:[
      {x:300,y:500,w:200,h:20},
      {x:700,y:420,w:180,h:20},
      {x:1100,y:360,w:220,h:20},
      {x:1400,y:480,w:260,h:20}
    ],
    ENEMIES:[
      {x:500,y:480,w:40,h:40,range:100,speed:80,dir:1},
      {x:1200,y:340,w:40,h:40,range:120,speed:100,dir:-1}
    ],
    GOAL:{x:1850,y:500,w:100,h:60}
  },
  {
    OBSTACLES:[
      {x:250,y:500,w:150,h:20},
      {x:600,y:420,w:120,h:20},
      {x:850,y:320,w:180,h:20},
      {x:1250,y:400,w:220,h:20},
      {x:1600,y:480,w:250,h:20}
    ],
    ENEMIES:[
      {x:700,y:400,w:40,h:40,range:80,speed:100,dir:1},
      {x:1450,y:370,w:40,h:40,range:140,speed:90,dir:-1},
      {x:1750,y:460,w:40,h:40,range:80,speed:70,dir:1}
    ],
    GOAL:{x:1850,y:480,w:100,h:60}
  }
];

// ----- ゲーム状態 -----
let currentStage=0;
const state={
  ball:{x:80,y:550,vx:0,vy:0,r:18},
  obstacles:[], enemies:[], goal:null,
  launched:false,finished:false,gameover:false,lastTime:performance.now(),shots:0
};

// ----- 入力管理 -----
let pointer={active:false,sx:0,sy:0,st:0,ex:0,ey:0};

function getCanvasPos(e){
  const rect=canvas.getBoundingClientRect();
  if(e.touches && e.touches.length>0){
    return {
      x:(e.touches[0].clientX-rect.left)*(canvas.width/rect.width),
      y:(e.touches[0].clientY-rect.top)*(canvas.height/rect.height)
    };
  }
  return {
    x:(e.clientX-rect.left)*(canvas.width/rect.width),
    y:(e.clientY-rect.top)*(canvas.height/rect.height)
  };
}

function startPointer(e){
  e.preventDefault();
  if(state.finished||state.gameover)return;
  const p=getCanvasPos(e);
  pointer.active=true;
  pointer.sx=p.x; pointer.sy=p.y; pointer.st=performance.now();
}
function movePointer(e){
  if(!pointer.active)return;
  const p=getCanvasPos(e);
  pointer.ex=p.x; pointer.ey=p.y;
}
function endPointer(e){
  e.preventDefault();
  if(!pointer.active)return;
  const dt=(performance.now()-pointer.st)/1000;
  const dx=(pointer.ex||pointer.sx)-pointer.sx;
  const dy=(pointer.ey||pointer.sy)-pointer.sy;
  if(dt>0.05){
    state.ball.vx=(dx/dt)*velocityMultiplier*0.8;
    state.ball.vy=(dy/dt)*velocityMultiplier*0.8;
    state.launched=true;
    state.shots++;
    document.getElementById('counter').textContent='フリック回数：'+state.shots;
  }
  pointer.active=false;
}

canvas.addEventListener('mousedown',startPointer);
canvas.addEventListener('mousemove',movePointer);
canvas.addEventListener('mouseup',endPointer);
canvas.addEventListener('touchstart',startPointer,{passive:false});
canvas.addEventListener('touchmove',movePointer,{passive:false});
canvas.addEventListener('touchend',endPointer,{passive:false});

// ----- 物理・衝突 -----
function circleRectCollision(ball,rect){
  const cx=Math.max(rect.x,Math.min(ball.x,rect.x+rect.w));
  const cy=Math.max(rect.y,Math.min(ball.y,rect.y+rect.h));
  const dx=ball.x-cx,dy=ball.y-cy;
  const dist2=dx*dx+dy*dy;
  if(dist2<ball.r*ball.r){
    const dist=Math.sqrt(dist2)||0.0001;
    const nx=dx/dist,ny=dy/dist;
    const penetration=ball.r-dist;
    return{hit:true,nx,ny,penetration};
  }
  return{hit:false};
}
function resolveCollision(ball,rect){
  const col=circleRectCollision(ball,rect);
  if(!col.hit)return false;
  ball.x+=col.nx*col.penetration;
  ball.y+=col.ny*col.penetration;
  const speed=ball.vx*col.nx+ball.vy*col.ny;
  const restitution=0.4;
  const impulse=-(1+restitution)*speed;
  ball.vx+=impulse*col.nx;
  ball.vy+=impulse*col.ny;
  return true;
}
function checkGoal(b,g){return(b.x>g.x&&b.x<g.x+g.w&&b.y>g.y&&b.y<g.y+g.h);}
function checkEnemyHit(b,en){
  const cx=Math.max(en.x,Math.min(b.x,en.x+en.w));
  const cy=Math.max(en.y,Math.min(b.y,en.y+en.h));
  const dx=b.x-cx,dy=b.y-cy;
  return(dx*dx+dy*dy<b.r*b.r);
}

// ----- 描画 -----
function draw(cameraX){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const offset=-cameraX;

  ctx.fillStyle='#bdefff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle='#8a5a3b';
  for(const o of state.obstacles) ctx.fillRect(o.x+offset,o.y,o.w,o.h);

  for(const en of state.enemies){
    ctx.fillStyle='#e74c3c';
    ctx.fillRect(en.x+offset,en.y,en.w,en.h);
  }

  ctx.fillStyle=state.finished?'#2ecc71':'#4caf50';
  ctx.fillRect(state.goal.x+offset,state.goal.y,state.goal.w,state.goal.h);
  ctx.fillStyle='#fff';
  ctx.font='18px sans-serif';
  ctx.textAlign='center';
  ctx.fillText('GOAL',state.goal.x+offset+state.goal.w/2,state.goal.y+state.goal.h/2+6);

  const b=state.ball;
  ctx.beginPath();
  ctx.arc(b.x+offset,b.y,b.r,0,Math.PI*2);
  ctx.fillStyle='#fff';ctx.fill();ctx.strokeStyle='#0003';ctx.stroke();

  if(pointer.active){
    ctx.strokeStyle='rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.moveTo(pointer.sx, pointer.sy);
    ctx.lineTo(pointer.ex||pointer.sx, pointer.ey||pointer.sy);
    ctx.stroke();
  }

  const status=document.getElementById('status');
  if(state.finished){status.textContent='CLEAR!!';status.style.color='green';}
  else if(state.gameover){status.textContent='GAME OVER';status.style.color='red';}
  else{status.textContent='';}
}

// ----- メインループ -----
let cameraX=0;
function step(now){
  const dt=Math.min((now-state.lastTime)/1000,1/15);
  state.lastTime=now;
  const b=state.ball;

  if(state.launched&&!state.finished&&!state.gameover){
    b.vy+=gravity*dt;
    b.x+=b.vx*dt; b.y+=b.vy*dt;

    if(b.x-b.r<0){b.x=b.r;b.vx=-b.vx*0.6;}
    if(b.x+b.r>WORLD_WIDTH){b.x=WORLD_WIDTH-b.r;b.vx=-b.vx*0.6;}
    if(b.y-b.r<0){b.y=b.r;b.vy=-b.vy*0.6;}
    if(b.y+b.r>canvas.height){b.y=canvas.height-b.r;b.vy=-b.vy*0.5;}

    let onGround=false;
    for(const o of state.obstacles){
      const hit=resolveCollision(b,o);
      if(hit && b.y<=o.y) onGround=true;
    }

    for(const en of state.enemies){
      en.x+=en.dir*en.speed*dt;
      if(en.x>en.startX+en.range||en.x<en.startX-en.range)en.dir*=-1;
      if(checkEnemyHit(b,en)) state.gameover=true;
    }

    if(onGround){
      b.vx*=groundFriction;
      if(Math.abs(b.vx)<1)b.vx=0;
    } else {
      b.vx*=airResistance; b.vy*=airResistance;
    }

    if(checkGoal(b,state.goal)){state.finished=true;state.launched=false;}
  }

  // === カメラ追尾（ボールが常に画面内） ===
  const targetX = b.x - canvas.width * 0.4; // ボールより少し先を見せる
  cameraX += (targetX - cameraX) * 0.1;     // スムーズ追尾
  cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - canvas.width));

  draw(cameraX);
  requestAnimationFrame(step);
}

// ----- ステージ管理 -----
function loadStage(n){
  const s=STAGES[n];
  state.obstacles=JSON.parse(JSON.stringify(s.OBSTACLES));
  state.enemies=JSON.parse(JSON.stringify(s.ENEMIES));
  for(const en of state.enemies) en.startX=en.x;
  state.goal={...s.GOAL};
  state.ball={x:80,y:550,vx:0,vy:0,r:18};
  state.launched=false;state.finished=false;state.gameover=false;
  state.shots=0;
  document.getElementById('counter').textContent='フリック回数：0';
  document.getElementById('stageLabel').textContent='ステージ：'+(n+1);
}
requestAnimationFrame(step);
loadStage(0);

// ----- UI -----
document.getElementById('grav').oninput=e=>{
  gravity=+e.target.value;
  document.getElementById('gravVal').textContent=gravity;
};
document.getElementById('vel').oninput=e=>{
  velocityMultiplier=+e.target.value;
  document.getElementById('velVal').textContent=velocityMultiplier.toFixed(1);
};
document.getElementById('reset').onclick=()=>loadStage(currentStage);
document.getElementById('next').onclick=()=>{
  currentStage=(currentStage+1)%STAGES.length;
  loadStage(currentStage);
};
</script>
</body>
</html>
