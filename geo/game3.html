<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>OSM 3D + Player (camera free, safe LOD)</title>
<style>
body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
#info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px;}
.joystick-container{position:absolute;left:40px;bottom:40px;width:120px;height:120px;z-index:20;}
.button-container{position:absolute;right:20px;bottom:20px;z-index:20;display:flex;flex-direction:column;gap:10px;}
.button-container button{width:80px;height:50px;font-size:16px;}
</style>
</head>
<body>
<div id="info">
  ドラッグでカメラ操作（左右上下自由） / ホイール無効（ズーム不可）。Tile Z=16, radius = <span id="rad">1</span>
</div>
<div class="joystick-container" id="joy"></div>
<div class="button-container">
  <button id="jumpBtn">ジャンプ</button>
  <button id="attackBtn">アタック</button>
</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<script>
/* ===================== 設定 / ユーティリティ ===================== */
const ZOOM = 16;
let LOAD_RADIUS = 1;
document.getElementById('rad').textContent = LOAD_RADIUS;

const MAX_CONCURRENT_FETCH = 3;
const OVERPASS_RETRY = 2;
const OVERPASS_DELAY_MS = 300;
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

/* WebMercator helpers */
const R = 6378137;
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }
function lonToMercX(lon){ return R * deg2rad(lon); }
function latToMercY(lat){ return R * Math.log(Math.tan(Math.PI/4 + deg2rad(lat)/2)); }
function mercXToLon(x){ return rad2deg(x / R); }
function mercYToLat(y){ return rad2deg(2 * Math.atan(Math.exp(y / R)) - Math.PI/2); }
function lonLatToMerc(lon, lat){ return { x: lonToMercX(lon), y: latToMercY(lat) }; }
function tile2lon(x,z){ return x / Math.pow(2,z) * 360 - 180; }
function tile2lat(y,z){ const n = Math.PI - 2 * Math.PI * y / Math.pow(2,z); return Math.atan(Math.sinh(n)) * 180 / Math.PI; }
function lonToTileX(lon, zoom){ return Math.floor((lon + 180) / 360 * Math.pow(2,zoom)); }
function latToTileY(lat, zoom){ const a = Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)); return Math.floor((1 - a/Math.PI)/2 * Math.pow(2,zoom)); }

/* ORIGIN (東京) */
const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT);

/* ===================== Three.js 初期化 ===================== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 120, 240);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = true;
controls.enableZoom = false;
controls.minPolarAngle = Math.PI * 0.20;
controls.maxPolarAngle = Math.PI * 0.8;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
dirLight.position.set(500,1000,500);
scene.add(dirLight);

/* ===================== OSM Tile & Building ===================== */
const loadedTiles = new Map();
const fetchQueue = [];
let activeFetches = 0;
const geoCache = new Map();
const imgCache = new Map();
const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");

function tileBBoxLonLat(x,y,z){ return { west: tile2lon(x,z), north: tile2lat(y,z), east: tile2lon(x+1,z), south: tile2lat(y+1,z) }; }
function bboxToOverpassQuery(bbox){ return `[out:json][timeout:25];(way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east}););(._;>;);out geom;`; }

async function fetchOverpassForTile(x,y,z, tries=0){
  const key = `${x}_${y}`;
  if(geoCache.has(key)) return geoCache.get(key);
  const bbox = tileBBoxLonLat(x,y,z);
  const query = bboxToOverpassQuery(bbox);
  try{
    activeFetches++;
    const res = await fetch(OVERPASS_URL, { method: "POST", body: query });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    const data = { bbox, json };
    geoCache.set(key, data);
    return data;
  } catch(err){
    if(tries < OVERPASS_RETRY){
      await new Promise(r=>setTimeout(r, 500 * Math.pow(2, tries)));
      return fetchOverpassForTile(x,y,z, tries+1);
    } else return null;
  } finally { activeFetches--; }
}
function enqueueFetch(fn){ return new Promise(resolve=>{ fetchQueue.push({fn,resolve}); processQueue(); }); }
function processQueue(){ if(activeFetches>=MAX_CONCURRENT_FETCH) return; const job = fetchQueue.shift(); if(!job) return; job.fn().then(r=>job.resolve(r)).finally(()=>setTimeout(processQueue, OVERPASS_DELAY_MS)); }

function mercToWorld(mx,my){ return { x: mx - ORIGIN_M.x, z: -(my - ORIGIN_M.y) }; }

function addFloorMeshToGroup(tex, bbox, group){
  const westMx = lonToMercX(bbox.west), eastMx = lonToMercX(bbox.east);
  const northMy = latToMercY(bbox.north), southMy = latToMercY(bbox.south);
  const mercW = eastMx - westMx, mercH = northMy - southMy;
  const centerX = (westMx + eastMx)/2 - ORIGIN_M.x;
  const centerZ = -((southMy + northMy)/2 - ORIGIN_M.y);
  const plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(mercW, mercH), new THREE.MeshPhongMaterial({ map: tex }));
  plane.rotation.x = -Math.PI/2;
  plane.position.set(centerX, 0, centerZ);
  group.add(plane);
}

/* ===================== 修正版 LOD 関数 ===================== */
function createExtrudeMeshFromWay(el){
  if(!el.geometry || el.geometry.length < 3) return new THREE.Mesh();
  const shape = new THREE.Shape();
  for(let i=0;i<el.geometry.length;i++){
    const pt = el.geometry[i];
    const m = lonLatToMerc(pt.lon, pt.lat);
    const w = mercToWorld(m.x, m.y);
    if(i===0) shape.moveTo(w.x, w.z); else shape.lineTo(w.x, w.z);
  }
  const tags = el.tags||{};
  let height = 10;
  if(tags.height) height = parseFloat(String(tags.height).replace('m',''))||height;
  else if(tags["building:levels"]) height = (parseFloat(tags["building:levels"])||1)*3;
  const geo = new THREE.ExtrudeBufferGeometry(shape, { depth: height, bevelEnabled: false });
  geo.rotateX(-Math.PI/2);
  geo.computeBoundingBox();
  const mat = new THREE.MeshPhongMaterial({ map: windowTex, color: 0xccccff });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.y = height/2;
  return mesh;
}

function createBoxLODFromWay(el, height){
  let minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;
  for(const pt of el.geometry){
    const m = lonLatToMerc(pt.lon, pt.lat);
    const w = mercToWorld(m.x, m.y);
    if(w.x<minX) minX=w.x; if(w.x>maxX) maxX=w.x;
    if(w.z<minZ) minZ=w.z; if(w.z>maxZ) maxZ=w.z;
  }
  const sx = Math.max(1, maxX-minX);
  const sz = Math.max(1, maxZ-minZ);
  const cx = (minX+maxX)/2;
  const cz = (minZ+maxZ)/2;
  const geo = new THREE.BoxBufferGeometry(sx, height, sz);
  geo.computeBoundingBox();
  const mat = new THREE.MeshPhongMaterial({ color: 0x999999 });
  const box = new THREE.Mesh(geo, mat);
  box.position.set(cx, height/2, cz);
  return box;
}

function createBuildingLOD(el){
  const tags = el.tags||{};
  let height = 10;
  if(tags.height) height = parseFloat(String(tags.height).replace('m',''))||height;
  else if(tags["building:levels"]) height = (parseFloat(tags["building:levels"])||1)*3;

  const lod = new THREE.LOD();
  try{ lod.addLevel(createExtrudeMeshFromWay(el), 0); } catch(e){ console.warn("detail fail", e); }
  lod.addLevel(createBoxLODFromWay(el, Math.max(3, height*0.9)), 200);
  lod.addLevel(createBoxLODFromWay(el, Math.max(3, height*0.7)), 800);
  lod.traverse(obj=>{ if(obj.geometry && !obj.geometry.boundingBox) obj.geometry.computeBoundingBox(); });
  return lod;
}

function addTileToScene(x,y,z,data){
  const key = `${x}_${y}`; if(loadedTiles.has(key)) return;
  const group = new THREE.Group(); group.userData = { x,y,z,bbox:data.bbox };
  const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
  if(imgCache.has(tileUrl)) addFloorMeshToGroup(imgCache.get(tileUrl), data.bbox, group);
  else new THREE.TextureLoader().load(tileUrl, tex => { tex.flipY = false; imgCache.set(tileUrl, tex); addFloorMeshToGroup(tex, data.bbox, group); });
  const els = data.json.elements || [];
  for(const el of els){ if(el.type !== "way" || !el.geometry) continue; try{ group.add(createBuildingLOD(el)); } catch(e){ console.warn("building create err", e); } }
  scene.add(group);
  loadedTiles.set(key, { group, lastUsed: Date.now(), bbox: data.bbox });
}

function unloadFarTiles(cx,cy){
  for(const [key, info] of Array.from(loadedTiles)){
    const [tx,ty] = key.split("_").map(n=>parseInt(n,10));
    if(Math.abs(tx-cx) > LOAD_RADIUS+1 || Math.abs(ty-cy) > LOAD_RADIUS+1){
      const grp = info.group; scene.remove(grp);
      grp.traverse(obj=>{ if(obj.geometry) obj.geometry.dispose(); if(obj.material) Array.isArray(obj.material)?obj.material.forEach(m=>m.dispose()):obj.material.dispose(); });
      loadedTiles.delete(key);
    }
  }
}

function cameraToLonLat(){
  const tx = controls.target.x, tz = controls.target.z;
  const m = { x: tx + ORIGIN_M.x, y: -(tz) + ORIGIN_M.y };
  return { lon: mercXToLon(m.x), lat: mercYToLat(m.y) };
}

let lastUpdate = 0; const MIN_UPDATE_INTERVAL = 1200;
async function updateTilesAroundCamera(){
  const now = performance.now();
  if(now - lastUpdate < MIN_UPDATE_INTERVAL) return;
  lastUpdate = now;
  const center = cameraToLonLat();
  const cx = lonToTileX(center.lon, ZOOM);
  const cy = latToTileY(center.lat, ZOOM);
  unloadFarTiles(cx,cy);
  for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
    for(let dy=-LOAD_RADIUS; dy<=LOAD_RADIUS; dy++){
      const tx = cx+dx, ty = cy+dy; const key = `${tx}_${ty}`;
      if(loadedTiles.has(key)){ loadedTiles.get(key).lastUsed = Date.now(); continue; }
      enqueueFetch(async()=>{ const res = await fetchOverpassForTile(tx,ty,ZOOM); if(res) addTileToScene(tx,ty,ZOOM,res); return res; });
    }
  }
}

/* ===================== Player + Camera ===================== */
const SCALE = 0.25;
const baseRadius = 10, baseHeight = 30;
const radius = baseRadius * SCALE;
const height = baseHeight * SCALE;

const player = new THREE.Mesh(
  new THREE.CylinderBufferGeometry(radius, radius, height, 12),
  new THREE.MeshPhongMaterial({ color: 0xff3333 })
);
player.position.set(0, height/2, 0);
scene.add(player);

const playerVel = new THREE.Vector3(0, 0, 0);
const targetVel = new THREE.Vector3(0, 0, 0);
const H_SPEED = 10.0;
const JUMP_SPEED = 30.0;
const GRAVITY = -60.0;
let canJump = true;
const clock = new THREE.Clock();

/* Joystick */
const joystick = nipplejs.create({ zone: document.getElementById('joy'), mode: 'static', position: { left: 60, top: 60 }, size: 120 });
let joyX = 0, joyY = 0;
joystick.on('move', (evt, data) => {
  const rad = data.angle.radian;
  const force = Math.min(data.force / 50, 1);
  joyX = Math.sin(rad) * force;
  joyY = Math.cos(rad) * force;
});
joystick.on('end', () => { joyX = 0; joyY = 0; });

/* Buttons */
document.getElementById('jumpBtn').addEventListener('touchstart', onJump);
document.getElementById('jumpBtn').addEventListener('mousedown', onJump);
function onJump(e){ if(canJump){ playerVel.y = JUMP_SPEED; canJump = false; } }
document.getElementById('attackBtn').addEventListener('click', ()=>{ console.log("Attack"); });

const DESIRED_DISTANCE = 120;

/* ===================== Main loop ===================== */
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);

  // Player movement
  const inputX = joyX, inputZ = joyY;
  if(Math.abs(inputX) > 0.001 || Math.abs(inputZ) > 0.001){
    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
    camDir.y = 0; camDir.normalize();
    const camRight = new THREE.Vector3(); camRight.crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();
    const moveWorld = new THREE.Vector3();
    moveWorld.addScaledVector(camDir, inputZ);
    moveWorld.addScaledVector(camRight, inputX);
    if(moveWorld.length() > 0.0001) moveWorld.normalize();
    targetVel.x = moveWorld.x * H_SPEED; targetVel.z = moveWorld.z * H_SPEED;
    const targetAngle = Math.atan2(moveWorld.x, moveWorld.z);
    const deltaRot = ((targetAngle - player.rotation.y + Math.PI) % (Math.PI*2)) - Math.PI;
    player.rotation.y += deltaRot * 0.35;
  } else { targetVel.x = 0; targetVel.z = 0; }

  const smooth = Math.min(1, 10*dt);
  playerVel.x = THREE.MathUtils.lerp(playerVel.x, targetVel.x, smooth);
  playerVel.z = THREE.MathUtils.lerp(playerVel.z, targetVel.z, smooth);
  player.position.x += playerVel.x * dt;
  player.position.z += playerVel.z * dt;

  playerVel.y += GRAVITY * dt;
  player.position.y += playerVel.y * dt;
  const groundY = height/2;
  if(player.position.y <= groundY){ player.position.y = groundY; playerVel.y = 0; canJump = true; }

  // Camera follow
  const desiredTarget = new THREE.Vector3().copy(player.position);
  controls.target.lerp(desiredTarget, 0.10);
  controls.update();
  const dir = new THREE.Vector3().subVectors(camera.position, controls.target);
  if(dir.length() < 0.001) dir.set(0,0,DESIRED_DISTANCE);
  dir.setLength(DESIRED_DISTANCE);
  camera.position.copy(controls.target).add(dir);

  updateTilesAroundCamera();
  scene.traverse(obj=>{ if(obj instanceof THREE.LOD) obj.update(camera); });

  renderer.render(scene, camera);
}
animate();

/* ===================== Resize & Keyboard ===================== */
window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });
</script>
</body>
</html>
