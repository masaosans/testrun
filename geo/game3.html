<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>OSM 3D + キャラクターゲーム</title>
<style>
body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
#info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px;}
#joystickContainer{
  position:absolute;
  bottom:40px;
  left:40px;
  width:150px;
  height:150px;
  touch-action:none;
  z-index:30;
}
#jumpBtn, #attackBtn{
  position:absolute;
  bottom:40px;
  width:80px;
  height:80px;
  border-radius:50%;
  background-color:rgba(255,255,255,0.7);
  font-size:18px;
  text-align:center;
  line-height:80px;
  z-index:30;
  user-select:none;
}
#jumpBtn{right:130px;}
#attackBtn{right:40px;}
</style>
</head>
<body>
<div id="info">
ドラッグで視点 / ホイールでズーム。タイル Z=16, radius = <span id="rad">1</span>
</div>

<div id="joystickContainer"></div>
<div id="jumpBtn">Jump</div>
<div id="attackBtn">Attack</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<script>
// ===================== OSM 3D Viewer 設定 =====================
const ZOOM = 16;
let LOAD_RADIUS = 1;
document.getElementById('rad').textContent = LOAD_RADIUS;

const MAX_CONCURRENT_FETCH = 3;
const OVERPASS_RETRY = 2;
const OVERPASS_DELAY_MS = 300;
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

const R = 6378137;
function deg2rad(d){ return d*Math.PI/180; }
function rad2deg(r){ return r*180/Math.PI; }
function lonToMercX(lon){ return R*deg2rad(lon); }
function latToMercY(lat){ return R*Math.log(Math.tan(Math.PI/4 + deg2rad(lat)/2)); }
function mercXToLon(x){ return rad2deg(x/R); }
function mercYToLat(y){ return rad2deg(2*Math.atan(Math.exp(y/R)) - Math.PI/2); }
function lonLatToMerc(lon,lat){ return {x:lonToMercX(lon), y:latToMercY(lat)}; }
function tile2lon(x,z){ return x/Math.pow(2,z)*360-180; }
function tile2lat(y,z){ const n=Math.PI-2*Math.PI*y/Math.pow(2,z); return Math.atan(Math.sinh(n))*180/Math.PI; }
function lonToTileX(lon,zoom){ return Math.floor((lon+180)/360*Math.pow(2,zoom)); }
function latToTileY(lat,zoom){ const a=Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180)); return Math.floor((1-a/Math.PI)/2*Math.pow(2,zoom)); }

const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT);

// ===================== Three.js 初期化 =====================
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0,50,100);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI/2.2;
controls.minPolarAngle = Math.PI/6;

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir = new THREE.DirectionalLight(0xffffff,0.9);
dir.position.set(500,1000,500);
scene.add(dir);

// ===================== キャラクター =====================
const playerGeo = new THREE.CapsuleGeometry(3,6,4,8);
const playerMat = new THREE.MeshPhongMaterial({color:0xff5555});
const player = new THREE.Mesh(playerGeo,playerMat);
player.position.set(0,10,0);
scene.add(player);

let velocityY=0;
const gravity=-0.5;
const jumpSpeed=8;
let onGround=true;

// ===================== Joystick =====================
let joystickDir={x:0,y:0};
const joystick = nipplejs.create({zone:document.getElementById('joystickContainer'), mode:'static', position:{left:75,top:75}, color:'blue'});

joystick.on('move',(evt,data)=>{
  const rad = data.angle.radian;
  const force = Math.min(data.force/50,1);
  joystickDir.x = Math.sin(rad)*force;
  joystickDir.y = Math.cos(rad)*force; // 上下反転済み
});
joystick.on('end',()=>{ joystickDir.x=0; joystickDir.y=0; });

// ===================== ボタン =====================
const jumpBtn=document.getElementById('jumpBtn');
const attackBtn=document.getElementById('attackBtn');

jumpBtn.addEventListener('touchstart',()=>{
  if(onGround){ velocityY=jumpSpeed; onGround=false; }
});
attackBtn.addEventListener('touchstart',()=>{ console.log("Attack"); });

// ===================== OSM タイル管理 =====================
const loadedTiles = new Map();
const fetchQueue = [];
let activeFetches=0;
const geoCache = new Map();
const imgCache = new Map();
const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");

function mercToWorld(mx,my){ return {x: mx-ORIGIN_M.x, z: -(my-ORIGIN_M.y)}; }

function tileBBoxLonLat(x,y,z){ return {west:tile2lon(x,z),north:tile2lat(y,z),east:tile2lon(x+1,z),south:tile2lat(y+1,z)}; }
function bboxToOverpassQuery(bbox){ return `[out:json][timeout:25];(way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east}););(._;>;);out geom;`; }

async function fetchOverpassForTile(x,y,z,tries=0){
  const key=`${x}_${y}`;
  if(geoCache.has(key)) return geoCache.get(key);
  const bbox=tileBBoxLonLat(x,y,z);
  const query=bboxToOverpassQuery(bbox);
  try{
    activeFetches++;
    const res=await fetch(OVERPASS_URL,{method:"POST",body:query});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const json=await res.json();
    const data={bbox,json};
    geoCache.set(key,data);
    return data;
  } catch(err){
    if(tries<OVERPASS_RETRY){ await new Promise(r=>setTimeout(r,500*Math.pow(2,tries))); return fetchOverpassForTile(x,y,z,tries+1);}
    else return null;
  } finally{ activeFetches--; }
}
function enqueueFetch(fn){ return new Promise(resolve=>{ fetchQueue.push({fn,resolve}); processQueue(); }); }
function processQueue(){
  if(activeFetches>=MAX_CONCURRENT_FETCH) return;
  const job=fetchQueue.shift(); if(!job) return;
  job.fn().then(r=>job.resolve(r)).finally(()=>setTimeout(processQueue,OVERPASS_DELAY_MS));
}

function addFloorMeshToGroup(tex,bbox,group){
  const westMx = lonToMercX(bbox.west), eastMx = lonToMercX(bbox.east);
  const northMy = latToMercY(bbox.north), southMy = latToMercY(bbox.south);
  const mercW = eastMx-westMx;
  const mercH = northMy-southMy;
  const centerX=(westMx+eastMx)/2-ORIGIN_M.x;
  const centerZ=-((southMy+northMy)/2-ORIGIN_M.y);
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(mercW,mercH),
    new THREE.MeshPhongMaterial({map:tex})
  );
  plane.rotation.x=-Math.PI/2;
  plane.position.set(centerX,0,centerZ);
  group.add(plane);
}

function createExtrudeMeshFromWay(el){
  const shape=new THREE.Shape();
  for(let i=0;i<el.geometry.length;i++){
    const pt=el.geometry[i];
    const m=lonLatToMerc(pt.lon,pt.lat);
    const w=mercToWorld(m.x,m.y);
    if(i===0) shape.moveTo(w.x,w.z); else shape.lineTo(w.x,w.z);
  }
  const tags=el.tags||{};
  let height=10;
  if(tags.height) height=parseFloat(String(tags.height).replace('m',''))||height;
  else if(tags["building:levels"]) height=(parseFloat(tags["building:levels"])||1)*3;
  const geo=new THREE.ExtrudeGeometry(shape,{depth:height,bevelEnabled:false});
  geo.rotateX(-Math.PI/2);
  geo.computeBoundingBox();
  geo.translate(0,-geo.boundingBox.min.y,0);
  const mat=new THREE.MeshPhongMaterial({map:windowTex,color:0xccccff});
  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.y=height/2;
  return mesh;
}
function createBuildingLOD(el){
  const tags=el.tags||{};
  let height=10;
  if(tags.height) height=parseFloat(String(tags.height).replace('m',''))||height;
  else if(tags["building:levels"]) height=(parseFloat(tags["building:levels"])||1)*3;
  const lod=new THREE.LOD();
  try{ lod.addLevel(createExtrudeMeshFromWay(el),0); } catch(e){ console.warn("detail fail",e); }
  return lod;
}
function addTileToScene(x,y,z,data){
  const key=`${x}_${y}`;
  if(loadedTiles.has(key)) return;
  const group=new THREE.Group();
  group.userData={x,y,z,bbox:data.bbox};
  const tileUrl=`https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
  if(imgCache.has(tileUrl)) addFloorMeshToGroup(imgCache.get(tileUrl),data.bbox,group);
  else new THREE.TextureLoader().load(tileUrl,tex=>{tex.flipY=false; imgCache.set(tileUrl,tex); addFloorMeshToGroup(tex,data.bbox,group);});
  const els=data.json.elements||[];
  for(const el of els){ if(el.type!=="way"||!el.geometry) continue; try{ group.add(createBuildingLOD(el)); } catch(e){ console.warn(e); } }
  scene.add(group);
  loadedTiles.set(key,{group,lastUsed:Date.now(),bbox:data.bbox});
}
function unloadFarTiles(cx,cy){
  for(const [key,info] of Array.from(loadedTiles)){
    const [tx,ty]=key.split("_").map(n=>parseInt(n,10));
    if(Math.abs(tx-cx)>LOAD_RADIUS+1 || Math.abs(ty-cy)>LOAD_RADIUS+1){
      const grp=info.group;
      scene.remove(grp);
      grp.traverse(obj=>{ if(obj.geometry) obj.geometry.dispose(); if(obj.material) Array.isArray(obj.material)?obj.material.forEach(m=>m.dispose()):obj.material.dispose(); });
      loadedTiles.delete(key);
    }
  }
}
function cameraToLonLat(){ const tx=controls.target.x; const tz=controls.target.z; const m={x:tx+ORIGIN_M.x, y:-(tz)+ORIGIN_M.y}; return {lon:mercXToLon(m.x),lat:mercYToLat(m.y)}; }

let lastUpdate=0;
const MIN_UPDATE_INTERVAL=1200;
async function updateTilesAroundCamera(){
  const now=performance.now();
  if(now-lastUpdate<MIN_UPDATE_INTERVAL) return;
  lastUpdate=now;
  const center=cameraToLonLat();
  const cx=lonToTileX(center.lon,ZOOM);
  const cy=latToTileY(center.lat,ZOOM);
  unloadFarTiles(cx,cy);
  for(let dx=-LOAD_RADIUS;dx<=LOAD_RADIUS;dx++){
    for(let dy=-LOAD_RADIUS;dy<=LOAD_RADIUS;dy++){
      const tx=cx+dx, ty=cy+dy;
      const key=`${tx}_${ty}`;
      if(loadedTiles.has(key)){ loadedTiles.get(key).lastUsed=Date.now(); continue; }
      enqueueFetch(async()=>{ const res=await fetchOverpassForTile(tx,ty,ZOOM); if(res) addTileToScene(tx,ty,ZOOM,res); return res; });
    }
  }
}

// ===================== プレイヤー更新 =====================
const moveSpeed=1.8;
function updatePlayer(){
  // XZ移動
  const dir=new THREE.Vector3(joystickDir.x,0,joystickDir.y);
  if(dir.length()>0.05){
    dir.normalize();
    const camYaw=Math.atan2(camera.position.x-player.position.x,camera.position.z-player.position.z);
    const moveAngle=Math.atan2(dir.x,dir.z);
    const finalAngle=moveAngle+camYaw;
    player.rotation.y += (finalAngle - player.rotation.y)*0.2;
    player.position.x += Math.sin(finalAngle)*moveSpeed;
    player.position.z += Math.cos(finalAngle)*moveSpeed;
  }

  // Yジャンプ
  velocityY += gravity*0.5;
  player.position.y += velocityY*0.5;
  if(player.position.y<=10){ player.position.y=10; velocityY=0; onGround=true; } else onGround=false;

  // カメラ追従
  const camOffset=new THREE.Vector3(0,30,50);
  const rotatedOffset=camOffset.clone();
  rotatedOffset.applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
  camera.position.lerp(player.position.clone().add(rotatedOffset),0.1);
  controls.target.lerp(player.position,0.1);
}

// ===================== Animate =====================
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  updatePlayer();
  for(const [,info] of loadedTiles){ info.group.traverse(obj=>{ if(obj instanceof THREE.LOD) obj.update(camera); }); }
  updateTilesAroundCamera();
  renderer.render(scene,camera);
}
animate();

// ===================== Resize =====================
window.addEventListener('resize',()=>{
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

// キーボードで radius
window.addEventListener('keydown', e=>{
  if(e.key==="+"){ LOAD_RADIUS=Math.min(4,LOAD_RADIUS+1); document.getElementById('rad').textContent=LOAD_RADIUS; }
  if(e.key==="-"){ LOAD_RADIUS=Math.max(0,LOAD_RADIUS-1); document.getElementById('rad').textContent=LOAD_RADIUS; }
});

processQueue();
console.log("OSM 3D + Player Game started.");
</script>
</body>
</html>
