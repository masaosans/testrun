<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>OSM + キャラクター移動 + ジャンプ 統合版</title>
<style>
body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
#info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px}
.joystick-container{position:absolute;left:50px;bottom:50px;z-index:20;width:120px;height:120px;}
.button-container{position:absolute;right:30px;bottom:50px;z-index:20;}
button{padding:15px;margin:5px;font-size:16px;}
</style>
</head>
<body>
<div id="info">ドラッグでカメラ操作 / ホイールでズーム</div>
<div class="joystick-container" id="joystick"></div>
<div class="button-container">
  <button id="jumpBtn">ジャンプ</button>
  <button id="attackBtn">アタック</button>
</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<script>
/* ===================== Three.js 初期化 ===================== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 10, 20);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = false;
controls.maxPolarAngle = Math.PI/2.2;
controls.minPolarAngle = Math.PI/6;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(500,1000,500);
scene.add(dir);

/* ===================== OSM 3Dマップ簡易床 ===================== */
const floorGroup = new THREE.Group();
scene.add(floorGroup);
const plane = new THREE.Mesh(
  new THREE.PlaneBufferGeometry(1000,1000),
  new THREE.MeshPhongMaterial({color:0x99cc99})
);
plane.rotation.x = -Math.PI/2;
floorGroup.add(plane);

/* ===================== キャラクター ===================== */
const charHeight = 2;
const charRadius = 0.5;
const character = new THREE.Mesh(
  new THREE.CylinderBufferGeometry(charRadius,charRadius,charHeight,16),
  new THREE.MeshPhongMaterial({color:0xff3333})
);
character.position.y = charHeight/2;
scene.add(character);

/* ===================== ジョイスティック ===================== */
const joystick = nipplejs.create({
  zone: document.getElementById('joystick'),
  mode:'static',
  position: { left: '50px', bottom:'50px' },
  color:'gray'
});

let moveVector = new THREE.Vector3();
joystick.on('move', function(evt, data){
  const rad = data.angle.radian;
  const force = data.force;
  moveVector.set(Math.sin(rad)*force,0,Math.cos(rad)*force);
});
joystick.on('end', ()=> moveVector.set(0,0,0));

/* ===================== 移動 & ジャンプ ===================== */
let velocityY = 0;
const gravity = -0.5;
const jumpForce = 0.25;
let onGround = true;

document.getElementById('jumpBtn').addEventListener('click',()=>{
  if(onGround){ velocityY = jumpForce; onGround=false; }
});

/* ===================== アニメーション ===================== */
function animate(){
  requestAnimationFrame(animate);

  // キャラクター移動
  if(moveVector.length()>0){
    // カメラ方向を基準に
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();

    const camRight = new THREE.Vector3();
    camRight.crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();

    const move = new THREE.Vector3();
    move.addScaledVector(camDir, -moveVector.z);
    move.addScaledVector(camRight, moveVector.x);
    move.multiplyScalar(0.3);

    character.position.add(move);

    // キャラクター向き
    if(move.length()>0.001){
      character.rotation.y = Math.atan2(move.x, move.z);
    }
  }

  // ジャンプ・重力
  velocityY += gravity*0.02;
  character.position.y += velocityY;
  if(character.position.y <= charHeight/2){
    character.position.y = charHeight/2;
    velocityY = 0;
    onGround = true;
  }

  // カメラ追従
  const camTarget = new THREE.Vector3();
  camTarget.copy(character.position);
  controls.target.lerp(camTarget,0.2);
  controls.update();

  renderer.render(scene,camera);
}
animate();

/* ===================== Resize ===================== */
window.addEventListener('resize',()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
