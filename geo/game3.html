<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>OSM 3D + Player (fixed controls) — Part 1/4</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  /* 基本レイアウト */
  html,body{height:100%;margin:0;padding:0;overflow:hidden;font-family:Arial,Helvetica,sans-serif;background:#a8dffb;}
  #info{
    position:absolute;
    left:10px;
    top:10px;
    z-index:30;
    background:rgba(255,255,255,0.92);
    padding:8px 10px;
    border-radius:8px;
    font-size:13px;
    box-shadow:0 2px 8px rgba(0,0,0,0.12);
  }

  /* ジョイスティック領域（左下） */
  .joystick-container{
    position:absolute;
    left:40px;
    bottom:40px;
    width:120px;
    height:120px;
    z-index:30;
    touch-action:none; /* タッチの既定動作を抑止 */
  }

  /* 右下のボタン群 */
  .button-container{
    position:absolute;
    right:20px;
    bottom:20px;
    z-index:30;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:flex-end;
  }
  .button-container button{
    width:88px;
    height:48px;
    font-size:16px;
    border-radius:8px;
    border:0;
    background:#2d8cff;
    color:#fff;
    box-shadow:0 2px 6px rgba(0,0,0,0.15);
    -webkit-tap-highlight-color: transparent;
  }
  .button-container button:active{ transform: translateY(1px); }

  /* 小さいヘルプ表示（右上） */
  #hint {
    position:absolute;
    right:10px;
    top:10px;
    z-index:30;
    background:rgba(0,0,0,0.45);
    color:#fff;
    padding:6px 8px;
    border-radius:6px;
    font-size:12px;
  }

  /* レスポンシブ微調整 */
  @media (max-width:600px){
    .joystick-container{ left:28px; bottom:28px; width:110px; height:110px; }
    .button-container{ right:12px; bottom:18px; }
    .button-container button{ width:76px; height:44px; font-size:15px; }
    #info{ font-size:12px; padding:6px 8px; }
  }
</style>
</head>
<body>
  <!-- 情報 -->
  <div id="info">
    ドラッグでカメラ操作（左右/上下自由）・ホイール無効。Tile Z=16, radius = <span id="rad">1</span>
  </div>

  <!-- 右上に簡単ヒント -->
  <div id="hint">左下：移動 / 右下：ジャンプ・アタック</div>

  <!-- ジョイスティック（左下） -->
  <div class="joystick-container" id="joy"></div>

  <!-- ジャンプ / アタックボタン（右下） -->
  <div class="button-container">
    <button id="jumpBtn" aria-label="ジャンプ">ジャンプ</button>
    <button id="attackBtn" aria-label="アタック">アタック</button>
  </div>

  <!-- Three.js r128, OrbitControls (r128 examples), nipplejs -->
  <!-- r128 の examples/js/controls/OrbitControls.js を使います（従来形式の script） -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<!-- ==================== Part 2 / 4 : Three.js 初期化 + OSM タイル管理 ==================== -->

<script>
// -----------------------------
// 基本 Three.js 初期化
// -----------------------------
let scene, camera, renderer, controls;
let player, playerDir = new THREE.Vector3(0,0,-1); // 前方向

initThree();

function initThree(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xa8dffb);

  camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(0, 40, 120);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableZoom = false; 
  controls.enablePan = false;
  controls.rotateSpeed = 0.9;
  controls.maxPolarAngle = Math.PI * 0.49;

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  addLights();
  addPlayerModel();
}

// 照明
function addLights(){
  const amb = new THREE.AmbientLight(0xffffff, 0.68);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.85);
  dir.position.set(120,150,90);
  scene.add(dir);
}

// 簡易プレイヤーモデル（円柱）
function addPlayerModel(){
  const g = new THREE.CylinderGeometry(6, 8, 18, 16);
  const m = new THREE.MeshLambertMaterial({color:0xff5533});
  player = new THREE.Mesh(g,m);
  player.position.set(0, 10, 0);
  player.castShadow = false;
  player.receiveShadow = false;
  scene.add(player);
}


// -------------------------------------------------
// OSM タイル設定
// -------------------------------------------------
const TILE_Z = 16;
const TILE_SIZE = 200;      // 地面タイルを仮想スケール化
const LOAD_RADIUS = 1;      // タイル読み込み範囲
document.getElementById("rad").textContent = LOAD_RADIUS;

const tileGroup = new THREE.Group();
scene.add(tileGroup);

// 平面タイルキャッシュ
const tileCache = new Map();  // key: `${x}_${y}` → THREE.Mesh

// 建物キャッシュ
const buildingCache = new Map();  // key: `${x}_${y}` → group

//------------------------------------------------
// 緯度経度 → メルカトルタイル XY
//------------------------------------------------
function lonLatToTileXY(lon, lat, z){
  const x = (lon + 180) / 360 * Math.pow(2, z);
  const y = (1 - Math.log(Math.tan(lat * Math.PI/180) + 1/Math.cos(lat * Math.PI/180))/Math.PI)/2 * Math.pow(2, z);
  return { x: Math.floor(x), y: Math.floor(y) };
}

// メルカトル逆変換（カメラから現在の Lon/Lat 推定）
function mercToLonLat(mx,my,z){
  const n = Math.pow(2,z);
  const lon = mx/n*360 - 180;
  const latRad = Math.atan(Math.sinh(Math.PI*(1-2*my/n)));
  const lat = latRad*180/Math.PI;
  return {lon,lat};
}

// 現在のカメラ位置から Lon/Lat を出す
// （TILE_SIZE を 1 タイルの世界距離として計算）
function cameraToLonLat(){
  const base = { lon:0, lat:0 }; // 基準 lon/lat（今は 0,0 起点の簡易版）
  const worldX = camera.position.x;
  const worldZ = camera.position.z;

  const tilesPer360 = Math.pow(2, TILE_Z);
  const degPerTile = 360 / tilesPer360;

  const lon = base.lon + (worldX / TILE_SIZE) * degPerTile;

  const baseTileY = lonLatToTileXY(base.lon, base.lat, TILE_Z).y;
  const yOffsetTiles = worldZ / TILE_SIZE;
  const my = baseTileY + yOffsetTiles;

  return mercToLonLat( (lon+180)/360 * tilesPer360, my, TILE_Z );
}


//---------------------------------------------
// タイル読み込み
//---------------------------------------------
async function loadTile(x, y){
  const key = `${x}_${y}`;
  if(tileCache.has(key)) return;

  const url = `https://tile.openstreetmap.org/${TILE_Z}/${x}/${y}.png`;
  const tex = new THREE.TextureLoader().load(url);

  const g = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
  const m = new THREE.MeshBasicMaterial({map:tex});
  const mesh = new THREE.Mesh(g, m);

  mesh.rotation.x = -Math.PI/2;
  const px = (x - centerTile.x) * TILE_SIZE;
  const pz = (y - centerTile.y) * TILE_SIZE;
  mesh.position.set(px, 0, pz);

  tileGroup.add(mesh);
  tileCache.set(key, mesh);

  loadBuildings(x,y);
}


//---------------------------------------------
// 建物（簡易LOD：高さランダム）
//---------------------------------------------
function loadBuildings(x,y){
  const key = `${x}_${y}`;
  if(buildingCache.has(key)) return;

  const g = new THREE.Group();

  for(let i=0;i<12;i++){
    const bx = (Math.random()*TILE_SIZE - TILE_SIZE/2) * 0.8;
    const bz = (Math.random()*TILE_SIZE - TILE_SIZE/2) * 0.8;
    const h = 20 + Math.random()*60;

    const geo = new THREE.BoxGeometry(10, h, 10);
    const mat = new THREE.MeshLambertMaterial({color:0xdddddd});
    const b = new THREE.Mesh(geo, mat);
    b.position.set(bx, h/2, bz);
    g.add(b);
  }

  const px = (x - centerTile.x)*TILE_SIZE;
  const pz = (y - centerTile.y)*TILE_SIZE;
  g.position.set(px, 0, pz);

  tileGroup.add(g);
  buildingCache.set(key, g);
}


//---------------------------------------------
// カメラ位置に応じてタイル更新
//---------------------------------------------
let centerTile = lonLatToTileXY(0,0, TILE_Z);

function updateTilesAroundCamera(){
  const lonlat = cameraToLonLat();
  const tile = lonLatToTileXY(lonlat.lon, lonlat.lat, TILE_Z);

  if(tile.x !== centerTile.x || tile.y !== centerTile.y){
    centerTile = tile;
  }

  for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
    for(let dy=-LOAD_RADIUS; dy<=LOAD_RADIUS; dy++){
      loadTile(tile.x + dx, tile.y + dy);
    }
  }
}

// =====================================================
// ジョイスティック UI（下部円）
// =====================================================
let joy = {
  active:false,
  sx:0, sy:0,
  x:0, y:0
};

const joystick = document.getElementById("joystick");
const joyBtn = document.getElementById("joy-btn");

// マウス・タッチ共通
function joyStart(e){
  joy.active = true;
  const r = joystick.getBoundingClientRect();
  joy.sx = (r.left + r.right)/2;
  joy.sy = (r.top + r.bottom)/2;
}
function joyMove(e){
  if(!joy.active) return;

  const t = (e.touches ? e.touches[0] : e);
  const dx = t.clientX - joy.sx;
  const dy = t.clientY - joy.sy;

  const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 45);
  const ang = Math.atan2(dy, dx);

  joy.x = Math.cos(ang) * (dist / 45);
  joy.y = Math.sin(ang) * (dist / 45);

  // 表示位置
  joyBtn.style.left = `${40 + joy.x * 40}px`;
  joyBtn.style.top  = `${40 + joy.y * 40}px`;
}
function joyEnd(){
  joy.active=false;
  joy.x=0; joy.y=0;
  joyBtn.style.left="40px";
  joyBtn.style.top ="40px";
}

["touchstart","mousedown"].forEach(e =>
  joystick.addEventListener(e, joyStart)
);
["touchmove","mousemove"].forEach(e =>
  window.addEventListener(e, joyMove)
);
["touchend","mouseup","mouseleave"].forEach(e =>
  window.addEventListener(e, joyEnd)
);


// =====================================================
// 進行方向（Joystick上＝カメラ方向前に）
// =====================================================
function getMoveVector(){
  if(!joy.active) return new THREE.Vector3(0,0,0);

  const jx = joy.x;
  const jy = joy.y;

  // ジョイスティック上を前：上が正面
  // （Three.js でカメラの forward を取得）
  const forward = new THREE.Vector3();
  camera.getWorldDirection(forward);

  // カメラの水平前方向
  forward.y = 0;
  forward.normalize();

  // カメラ右方向
  const right = new THREE.Vector3();
  right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(-1);

  // js の y は上下逆なので反転
  const v = new THREE.Vector3()
      .addScaledVector(forward, jy)
      .addScaledVector(right,  jx);

  if(v.length()>1) v.normalize();
  return v;
}


// =====================================================
// プレイヤー移動 & 向き
// =====================================================
let velocityY = 0;     // ジャンプ用
const gravity = -0.52; // 重力

function updatePlayerMovement(dt){
  const v = getMoveVector();

  // 回転（移動しているときのみ、向ける）
  if(v.length() > 0.01){
    const look = v.clone().normalize();
    const rotY = Math.atan2(look.x, look.z);
    player.rotation.y = rotY;

    // 移動速度
    const speed = 60;
    player.position.x += look.x * speed * dt;
    player.position.z += look.z * speed * dt;
  }

  // --------- ジャンプ & 重力 ----------
  player.position.y += velocityY * dt;
  velocityY += gravity;

  // 着地
  if(player.position.y < 10){
    player.position.y = 10;
    velocityY = 0;
    isGrounded = true;
  }
}


// =====================================================
// ジャンプ
// =====================================================
let isGrounded = true;

document.getElementById("jump-btn").addEventListener("touchstart", jump);
document.getElementById("jump-btn").addEventListener("mousedown", jump);

function jump(){
  if(isGrounded){
    velocityY = 22;   // 放物線になる自然なジャンプ
    isGrounded = false;
  }
}


// =====================================================
// 攻撃ボタン（今は未実装）
// =====================================================
document.getElementById("attack-btn").addEventListener("touchstart", ()=>{});
document.getElementById("attack-btn").addEventListener("mousedown", ()=>{});


// =====================================================
// カメラ：追従＋手動旋回（横/縦）
// =====================================================
let camYaw = 0;    // 左右角度
let camPitch = -15 * Math.PI/180; // 上下角度
const camDist = 120; // プレイヤーとの距離

// マウスドラッグでカメラ回転
let camDrag = false, px=0, py=0;
renderer.domElement.addEventListener("mousedown", e=>{
  camDrag=true; px=e.clientX; py=e.clientY;
});
window.addEventListener("mouseup", ()=> camDrag=false);
window.addEventListener("mousemove", e=>{
  if(!camDrag) return;
  const dx = e.clientX-px;
  const dy = e.clientY-py;
  px=e.clientX; py=e.clientY;

  camYaw -= dx * 0.004;
  camPitch -= dy * 0.003;

  // 上下角度の制限
  camPitch = Math.max(-75*Math.PI/180, Math.min(5*Math.PI/180, camPitch));
});

function updateCamera(){
  const cx = player.position.x + Math.sin(camYaw) * camDist;
  const cz = player.position.z + Math.cos(camYaw) * camDist;
  const cy = player.position.y + Math.sin(-camPitch) * camDist*0.5 + 40;

  camera.position.set(cx, cy, cz);
  camera.lookAt(player.position);
}

// =====================================================
// アニメーションループ
// =====================================================
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);

  const dt = Math.min(clock.getDelta(), 0.05); // delta秒（0.05でクランプ）

  // --- プレイヤー移動 ---
  updatePlayerMovement(dt);

  // --- カメラ ---
  updateCamera();

  // --- タイル更新（カメラ位置に応じて） ---
  updateTilesAroundCamera();

  // --- LOD更新（建物） ---
  for(const [,info] of loadedTiles){
    info.group.traverse(obj=>{
      if(obj instanceof THREE.LOD) obj.update(camera);
    });
  }

  // --- レンダリング ---
  renderer.render(scene, camera);
}
animate();

// =====================================================
// ウィンドウリサイズ対応
// =====================================================
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// =====================================================
// タイルロード処理開始
// =====================================================
processQueue();

console.log("OSM + Player (camera free, jump while moving) initialized.");
</script>

</body>
</html>
