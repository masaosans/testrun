<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Dynamic OSM 3D with LOD (Improved)</title>
<style>
  body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
  #info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px}
</style>
</head>
<body>
<div id="info">ドラッグで移動 / ホイールでズーム。状況はコンソール参照。<br>Tile Z=16, radius = <span id="rad">1</span>（+ / - で変更）</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===========================
   設定（必要なら調整）
   =========================== */
const ZOOM = 16;
let LOAD_RADIUS = 1;
document.getElementById('rad').textContent = LOAD_RADIUS;

const TILE_SIZE_M = 200;
const MAX_CONCURRENT_FETCH = 3;
const OVERPASS_RETRY = 2;
const OVERPASS_DELAY_MS = 300;
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

/* ===========================
   WebMercator ユーティリティ
   =========================== */
const R = 6378137;
function lonToMercX(lon){ return R * lon * Math.PI/180; }
function latToMercY(lat){ const rad = lat * Math.PI/180; return R * Math.log(Math.tan(Math.PI/4 + rad/2)); }
function mercXToLon(x){ return (x / R) * 180 / Math.PI; }
function mercYToLat(y){ return (2 * Math.atan(Math.exp(y / R)) - Math.PI/2) * 180 / Math.PI; }

function tile2lon(x,z){ return x / Math.pow(2,z) * 360 - 180; }
function tile2lat(y,z){ const n = Math.PI - 2 * Math.PI * y / Math.pow(2,z); return (180 / Math.PI) * Math.atan(Math.sinh(n)); }

function lonLatToMerc(lon, lat){ return { x: lonToMercX(lon), y: latToMercY(lat) }; }
function mercToWorld(mx, my, origin){ return { x: mx - origin.x, z: -(my - origin.y) }; }
function worldToMerc(wx, wz, origin){ return { x: wx + origin.x, y: -(wz) + origin.y }; }
function mercToLonLat(mx, my){ return { lon: mercXToLon(mx), lat: mercYToLat(my) }; }

/* ===========================
   Three.js 初期化
   =========================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 800, 1200);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(500,1000,500); scene.add(dir);

/* 床の基準原点（mercator） — 東京中心を初期原点に */
const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT);

/* グローバルキャッシュ */
const loadedTiles = new Map(); // key = `${x}_${y}` -> { group, lastUsed, bbox }
const fetchQueue = [];
let activeFetches = 0;
const geoCache = new Map();   // "x_y" -> {bbox,json}
const imgCache = new Map();   // tileUrl -> texture

/* 窓テクスチャ */
const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");

/* ===========================
   Tile/Overpass helpers
   =========================== */
function tileBBoxLonLat(x,y,z){
  return { west: tile2lon(x,z), north: tile2lat(y,z), east: tile2lon(x+1,z), south: tile2lat(y+1,z) };
}
function bboxToOverpassQuery(bbox){
  return `[out:json][timeout:25];
(
  way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
);
(._;>;);
out geom;`;
}

/* Fetch with retry + concurrency handled by queue */
async function fetchOverpassForTile(x,y,z, tries=0){
  const key = `${x}_${y}`;
  if(geoCache.has(key)) return geoCache.get(key);
  const bbox = tileBBoxLonLat(x,y,z);
  const query = bboxToOverpassQuery(bbox);
  try {
    activeFetches++;
    const res = await fetch(OVERPASS_URL, { method: "POST", body: query });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    geoCache.set(key, { bbox, json });
    return { bbox, json };
  } catch(err){
    console.warn("Overpass fetch error", x,y, err);
    if(tries < OVERPASS_RETRY){
      await new Promise(r=>setTimeout(r, 500 * Math.pow(2, tries)));
      return fetchOverpassForTile(x,y,z, tries+1);
    } else {
      return null;
    }
  } finally {
    activeFetches--;
  }
}

function enqueueFetch(fn){
  return new Promise(resolve => { fetchQueue.push({fn, resolve}); processQueue(); });
}
function processQueue(){
  if(activeFetches >= MAX_CONCURRENT_FETCH) return;
  const job = fetchQueue.shift();
  if(!job) return;
  job.fn().then(r => job.resolve(r)).finally(()=> setTimeout(processQueue, OVERPASS_DELAY_MS));
}

/* ===========================
   Building creation (LOD + grounding)
   =========================== */

/* create extruded geometry, rotate so height is along Y, and translate so bottom sits at y=0 */
function createExtrudeMeshFromWay(el, bbox){
  // Build shape in world coords (X,Y) where Y is north-south -> we'll use X = mercX, Y = mercY
  const shape = new THREE.Shape();
  for(let i=0;i<el.geometry.length;i++){
    const pt = el.geometry[i];
    const m = lonLatToMerc(pt.lon, pt.lat);
    // convert to world relative to ORIGIN_M
    const w = mercToWorld(m.x, m.y, ORIGIN_M);
    if(i===0) shape.moveTo(w.x, w.z);
    else shape.lineTo(w.x, w.z);
  }

  const tags = el.tags || {};
  let height = 10;
  if(tags.height) { height = parseFloat(String(tags.height).replace('m','')) || height; }
  else if(tags["building:levels"]) { height = (parseFloat(tags["building:levels"])||1) * 3; }

  // create extrude geometry (extrudes along +Z)
  const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false });

  // rotate so extrude (Z) becomes Y: rotate -90deg around X
  geo.rotateX(-Math.PI/2);

  // compute bounding box and translate geometry so minY == 0
  geo.computeBoundingBox();
  const minY = geo.boundingBox.min.y;
  if(minY !== 0) {
    const ty = -minY;
    geo.translate(0, ty, 0);
  }

  const mat = new THREE.MeshPhongMaterial({ map: windowTex, color: 0xccccff });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = false;
  mesh.receiveShadow = false;

  return {mesh, height};
}

/* create simple box LOD */
function createBoxLODFromWay(el, height){
  // compute bbox of footprint in world coords
  let minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;
  for(let i=0;i<el.geometry.length;i++){
    const pt = el.geometry[i];
    const m = lonLatToMerc(pt.lon, pt.lat);
    const w = mercToWorld(m.x, m.y, ORIGIN_M);
    if(w.x < minX) minX = w.x; if(w.x > maxX) maxX = w.x;
    if(w.z < minZ) minZ = w.z; if(w.z > maxZ) maxZ = w.z;
  }
  const sx = Math.max(1, maxX - minX);
  const sz = Math.max(1, maxZ - minZ);
  const cx = (minX + maxX) / 2;
  const cz = (minZ + maxZ) / 2;

  const boxGeo = new THREE.BoxGeometry(sx, height, sz);
  const boxMat = new THREE.MeshPhongMaterial({ color: 0x999999 });
  const box = new THREE.Mesh(boxGeo, boxMat);
  box.position.set(cx, height/2, cz);
  return box;
}

/* create LOD: detailed (extrude) + mid (box) + far (small box) */
function createBuildingLOD(el){
  const lod = new THREE.LOD();
  const detailed = createExtrudeMeshFromWay(el).mesh;
  lod.addLevel(detailed, 0);

  // compute approximate height for mid/far boxes
  const tags = el.tags || {};
  let height = 10;
  if(tags.height) { height = parseFloat(String(tags.height).replace('m','')) || height; }
  else if(tags["building:levels"]) { height = (parseFloat(tags["building:levels"])||1) * 3; }

  const mid = createBoxLODFromWay(el, Math.max(3, height * 0.9));
  lod.addLevel(mid, 200); // switch to mid at 200 units

  const far = createBoxLODFromWay(el, Math.max(3, height * 0.7));
  lod.addLevel(far, 800); // switch to far at 800 units

  // set lod position at origin (meshes already in world coords), so no translate
  return lod;
}

/* ===========================
   add tile group
   =========================== */
function addTileToScene(x,y,z, data){
  const key = `${x}_${y}`;
  if(loadedTiles.has(key)) return;

  const group = new THREE.Group();
  group.userData = { x, y, z, bbox: data.bbox };

  // add floor image (centered)
  const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
  if(imgCache.has(tileUrl)){
    const tex = imgCache.get(tileUrl);
    addFloorMeshToGroup(tex, data.bbox, group);
  } else {
    new THREE.TextureLoader().load(tileUrl, tex => {
      tex.flipY = false;
      imgCache.set(tileUrl, tex);
      addFloorMeshToGroup(tex, data.bbox, group);
    }, undefined, err => console.warn("tile image load err", tileUrl, err));
  }

  // add buildings (LOD)
  const els = data.json.elements || [];
  for(const el of els){
    if(el.type !== "way" || !el.geometry) continue;
    try {
      const lod = createBuildingLOD(el);
      group.add(lod);
    } catch(e){
      console.warn("building create err", e);
    }
  }

  scene.add(group);
  loadedTiles.set(key, { group, lastUsed: Date.now(), bbox: data.bbox });
  console.log(`Tile added ${key} (buildings: ${els.length})`);
}

function addFloorMeshToGroup(tex, bbox, group){
  // calculate merc meter size
  const westMx = lonToMercX(bbox.west), eastMx = lonToMercX(bbox.east);
  const northMy = latToMercY(bbox.north), southMy = latToMercY(bbox.south);
  const mercW = eastMx - westMx;
  const mercH = northMy - southMy;

  const centerMx = (westMx + eastMx) / 2;
  const centerMy = (northMy + southMy) / 2;
  const centerWorld = mercToWorld(centerMx, centerMy, ORIGIN_M);

  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(mercW, mercH),
    new THREE.MeshPhongMaterial({ map: tex })
  );
  plane.rotation.x = -Math.PI/2;
  plane.position.set(centerWorld.x, 0, centerWorld.z);
  group.add(plane);
}

/* ===========================
   unload far tiles
   =========================== */
function unloadFarTiles(centerTileX, centerTileY){
  for(const [key, info] of Array.from(loadedTiles)){
    const [tx, ty] = key.split("_").map(n=>parseInt(n,10));
    if(Math.abs(tx - centerTileX) > LOAD_RADIUS + 1 || Math.abs(ty - centerTileY) > LOAD_RADIUS + 1){
      // dispose
      const grp = info.group;
      scene.remove(grp);
      grp.traverse(obj=>{
        if(obj.geometry){ obj.geometry.dispose(); }
        if(obj.material){
          if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
          else obj.material.dispose();
        }
      });
      loadedTiles.delete(key);
      console.log(`Tile unloaded ${key}`);
    }
  }
}

/* ===========================
   camera <-> lonlat helpers
   =========================== */
function worldToMercCoords(wx, wz){ return worldToMerc(wx, wz, ORIGIN_M); }
function cameraToLonLat(){
  const tx = controls.target.x;
  const tz = controls.target.z;
  const m = worldToMerc(tx, tz, ORIGIN_M);
  return mercToLonLat(m.x, m.y);
}

/* helpers for tile indices */
function lonToTileX(lon, zoom){ return Math.floor((lon + 180) / 360 * Math.pow(2,zoom)); }
function latToTileY(lat, zoom){
  const a = Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180));
  return Math.floor((1 - a/Math.PI) / 2 * Math.pow(2,zoom));
}

/* ===========================
   Tile update logic
   =========================== */
let lastUpdate = 0;
const MIN_UPDATE_INTERVAL = 1200;

async function updateTilesAroundCamera(){
  const now = performance.now();
  if(now - lastUpdate < MIN_UPDATE_INTERVAL) return;
  lastUpdate = now;

  const center = cameraToLonLat();
  const cx = lonToTileX(center.lon, ZOOM);
  const cy = latToTileY(center.lat, ZOOM);

  unloadFarTiles(cx, cy);

  for(let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++){
    for(let dy = -LOAD_RADIUS; dy <= LOAD_RADIUS; dy++){
      const tx = cx + dx, ty = cy + dy;
      const key = `${tx}_${ty}`;
      if(loadedTiles.has(key)){
        loadedTiles.get(key).lastUsed = Date.now();
        continue;
      }
      // enqueue fetch
      enqueueFetch(async ()=> {
        const res = await fetchOverpassForTile(tx, ty, ZOOM);
        if(res) addTileToScene(tx, ty, ZOOM, res);
        return res;
      });
    }
  }
}

/* ===========================
   Animation loop
   =========================== */
function animate(){
  requestAnimationFrame(animate);
  controls.update();

  // Update LODs: call LOD.update? Three's LOD is automatic via camera, but we must set camera reference when adding: call update on each LOD when rendering
  for(const [, info] of loadedTiles){
    info.group.traverse(obj=>{
      if(obj instanceof THREE.LOD) obj.update(camera);
    });
  }

  updateTilesAroundCamera();
  renderer.render(scene, camera);
}
animate();

/* resize */
window.addEventListener('resize', ()=> {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* keyboard radius */
window.addEventListener('keydown', (e)=>{
  if(e.key === "+"){ LOAD_RADIUS = Math.min(4, LOAD_RADIUS+1); document.getElementById('rad').textContent = LOAD_RADIUS; }
  if(e.key === "-"){ LOAD_RADIUS = Math.max(0, LOAD_RADIUS-1); document.getElementById('rad').textContent = LOAD_RADIUS; }
});

/* queue processor kickoff */
processQueue();

console.log("Improved Dynamic OSM viewer (LOD & grounding) started.");

</script>
</body>
</html>
