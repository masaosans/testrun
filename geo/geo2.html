<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Dynamic OSM 3D with LOD (Alignment Fix)</title>
<style>
  body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
  #info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px}
</style>
</head>
<body>
<div id="info">ドラッグで移動 / ホイールでズーム。状況はコンソール参照。<br>Tile Z=16, radius = <span id="rad">1</span>（+ / - で変更）</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===========================
   設定
   =========================== */
const ZOOM = 16;
let LOAD_RADIUS = 1;
document.getElementById('rad').textContent = LOAD_RADIUS;

const MAX_CONCURRENT_FETCH = 3;
const OVERPASS_RETRY = 2;
const OVERPASS_DELAY_MS = 300;
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

/* ===========================
   WebMercator / Tile helpers
   Ensures we use the exact same math for tiles and features
   =========================== */
const R = 6378137;
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

// lon/lat -> WebMercator (meters), consistent with EPSG:3857
function lonToMercX(lon){ return R * deg2rad(lon); }
function latToMercY(lat){
  const rad = deg2rad(lat);
  return R * Math.log(Math.tan(Math.PI/4 + rad/2));
}
function mercXToLon(x){ return rad2deg(x / R); }
function mercYToLat(y){ return rad2deg(2 * Math.atan(Math.exp(y / R)) - Math.PI/2); }

// tile->lon/lat using standard WebMercator formulas (consistent with OSM)
function tile2lon(x,z){ return x / Math.pow(2,z) * 360 - 180; }
function tile2lat(y,z){
  // use atan(sinh(n)) formulation — standard and stable
  const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
  return Math.atan(Math.sinh(n)) * 180 / Math.PI;
}

// convert lon/lat to merc coords (object with x,y meters)
function lonLatToMerc(lon, lat){ return { x: lonToMercX(lon), y: latToMercY(lat) }; }

// merc (meters) -> Three.js world coords using an origin (ORIGIN_M)
function mercToWorld(mx, my, origin){
  // world.x = mx - origin.x
  // world.z = -(my - origin.y)  (so +z points SOUTH)
  return { x: mx - origin.x, z: -(my - origin.y) };
}
function worldToMerc(wx, wz, origin){
  // inverse of mercToWorld
  return { x: wx + origin.x, y: -(wz) + origin.y };
}

/* ===========================
   Three.js 初期化
   =========================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 800, 1200);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(500,1000,500); scene.add(dir);

/* 世界原点 (mercator) を東京中心に設定 */
const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT);

/* キャッシュ & 管理 */
const loadedTiles = new Map(); // key "x_y" => { group, lastUsed, bbox }
const fetchQueue = [];
let activeFetches = 0;
const geoCache = new Map(); // key "x_y" -> {bbox, json}
const imgCache = new Map(); // tileUrl -> texture

const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");

/* ===========================
   Tile bbox and query
   =========================== */
function tileBBoxLonLat(x,y,z){
  return {
    west: tile2lon(x,z),
    north: tile2lat(y,z),
    east: tile2lon(x+1,z),
    south: tile2lat(y+1,z)
  };
}
function bboxToOverpassQuery(bbox){
  return `[out:json][timeout:25];
(
  way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
);
(._;>;);
out geom;`;
}

/* ===========================
   Fetch management (queue + concurrency)
   =========================== */
async function fetchOverpassForTile(x,y,z, tries=0){
  const key = `${x}_${y}`;
  if(geoCache.has(key)) return geoCache.get(key);
  const bbox = tileBBoxLonLat(x,y,z);
  const query = bboxToOverpassQuery(bbox);

  try {
    activeFetches++;
    const res = await fetch(OVERPASS_URL, { method: "POST", body: query });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    const data = { bbox, json };
    geoCache.set(key, data);
    return data;
  } catch(err){
    console.warn("Overpass fetch error", x,y, err);
    if(tries < OVERPASS_RETRY){
      await new Promise(r=>setTimeout(r, 500 * Math.pow(2, tries)));
      return fetchOverpassForTile(x,y,z, tries+1);
    } else {
      return null;
    }
  } finally {
    activeFetches--;
  }
}

function enqueueFetch(fn){
  return new Promise(resolve => { fetchQueue.push({fn, resolve}); processQueue(); });
}
function processQueue(){
  if(activeFetches >= MAX_CONCURRENT_FETCH) return;
  const job = fetchQueue.shift();
  if(!job) return;
  job.fn().then(r => job.resolve(r)).finally(()=> setTimeout(processQueue, OVERPASS_DELAY_MS));
}

/* ===========================
   Building creation (grounded + LOD)
   =========================== */

/* Create extruded mesh from an Overpass "way" element.
   Important: we convert lon/lat -> merc -> world using EXACT same functions used for tile geometry.
   Then we extrude and rotate so that bottom sits at y=0 (ground). */
function createExtrudeMeshFromWay(el){
  // shape in world X,Z coordinates (units = meters)
  const shape = new THREE.Shape();
  for(let i=0;i<el.geometry.length;i++){
    const pt = el.geometry[i];
    const m = lonLatToMerc(pt.lon, pt.lat);        // meters
    const w = mercToWorld(m.x, m.y, ORIGIN_M);    // world coords
    if(i===0) shape.moveTo(w.x, w.z);
    else shape.lineTo(w.x, w.z);
  }

  // height from tags
  const tags = el.tags || {};
  let height = 10;
  if(tags.height) { height = parseFloat(String(tags.height).replace('m','')) || height; }
  else if(tags["building:levels"]) { height = (parseFloat(tags["building:levels"])||1) * 3; }

  // extrude along +Z, then rotate so extrusion becomes Y
  const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false });
  geo.rotateX(-Math.PI/2);

  // ensure bottom sits at y=0: translate geometry by -minY
  geo.computeBoundingBox();
  const minY = geo.boundingBox.min.y;
  if(minY !== 0){
    geo.translate(0, -minY, 0);
  }

  const mat = new THREE.MeshPhongMaterial({ map: windowTex, color: 0xccccff });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  return { mesh, height };
}

/* Create simple box approximations for LOD */
function createBoxLODFromWay(el, height){
  // compute footprint bbox in world coordinates
  let minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;
  for(const pt of el.geometry){
    const m = lonLatToMerc(pt.lon, pt.lat);
    const w = mercToWorld(m.x, m.y, ORIGIN_M);
    if(w.x < minX) minX = w.x; if(w.x > maxX) maxX = w.x;
    if(w.z < minZ) minZ = w.z; if(w.z > maxZ) maxZ = w.z;
  }
  const sx = Math.max(1, maxX - minX);
  const sz = Math.max(1, maxZ - minZ);
  const cx = (minX + maxX) / 2;
  const cz = (minZ + maxZ) / 2;

  const boxGeo = new THREE.BoxGeometry(sx, height, sz);
  const boxMat = new THREE.MeshPhongMaterial({ color: 0x999999 });
  const box = new THREE.Mesh(boxGeo, boxMat);
  box.position.set(cx, height/2, cz);
  return box;
}

function createBuildingLOD(el){
  const tags = el.tags || {};
  let height = 10;
  if(tags.height) { height = parseFloat(String(tags.height).replace('m','')) || height; }
  else if(tags["building:levels"]) { height = (parseFloat(tags["building:levels"])||1) * 3; }

  const lod = new THREE.LOD();
  // detailed
  try{
    const det = createExtrudeMeshFromWay(el);
    lod.addLevel(det.mesh, 0);
  } catch(e){
    console.warn("create detailed failed", e);
  }
  // mid
  const mid = createBoxLODFromWay(el, Math.max(3, height * 0.9));
  lod.addLevel(mid, 200);
  // far
  const far = createBoxLODFromWay(el, Math.max(3, height * 0.7));
  lod.addLevel(far, 800);
  return lod;
}

/* ===========================
   Tile add / floor placement
   =========================== */
function addFloorMeshToGroup(tex, bbox, group){
  // compute merc sizes from bbox using same lon/lat->merc functions
  const westMx = lonToMercX(bbox.west), eastMx = lonToMercX(bbox.east);
  const northMy = latToMercY(bbox.north), southMy = latToMercY(bbox.south);
  const mercW = eastMx - westMx;
  const mercH = northMy - southMy;

  const centerMx = (westMx + eastMx) / 2;
  const centerMy = (northMy + southMy) / 2;
  const centerWorld = mercToWorld(centerMx, centerMy, ORIGIN_M);

  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(mercW, mercH),
    new THREE.MeshPhongMaterial({ map: tex })
  );
  plane.rotation.x = -Math.PI/2;
  plane.position.set(centerWorld.x, 0, centerWorld.z);
  group.add(plane);
}

function addTileToScene(x,y,z, data){
  const key = `${x}_${y}`;
  if(loadedTiles.has(key)) return;

  const group = new THREE.Group();
  group.userData = { x, y, z, bbox: data.bbox };

  // floor image
  const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
  if(imgCache.has(tileUrl)){
    addFloorMeshToGroup(imgCache.get(tileUrl), data.bbox, group);
  } else {
    new THREE.TextureLoader().load(tileUrl, tex => {
      tex.flipY = false; // ensure orientation matches our plane geometry use
      imgCache.set(tileUrl, tex);
      addFloorMeshToGroup(tex, data.bbox, group);
    }, undefined, err => console.warn("tile image load err", tileUrl, err));
  }

  // buildings as LODs
  const els = data.json.elements || [];
  for(const el of els){
    if(el.type !== "way" || !el.geometry) continue;
    try{
      const lod = createBuildingLOD(el);
      group.add(lod);
    } catch(e){
      console.warn("building create err", e);
    }
  }

  scene.add(group);
  loadedTiles.set(key, { group, lastUsed: Date.now(), bbox: data.bbox });
  console.log(`Tile added ${key} (features: ${els.length})`);
}

/* ===========================
   Unload logic
   =========================== */
function unloadFarTiles(centerTileX, centerTileY){
  for(const [key, info] of Array.from(loadedTiles)){
    const [tx, ty] = key.split("_").map(n=>parseInt(n,10));
    if(Math.abs(tx - centerTileX) > LOAD_RADIUS + 1 || Math.abs(ty - centerTileY) > LOAD_RADIUS + 1){
      const grp = info.group;
      scene.remove(grp);
      grp.traverse(obj=>{
        if(obj.geometry){ obj.geometry.dispose(); }
        if(obj.material){
          if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
          else obj.material.dispose();
        }
      });
      loadedTiles.delete(key);
      console.log(`Tile unloaded ${key}`);
    }
  }
}

/* ===========================
   Camera <-> lon/lat helpers
   =========================== */
function cameraToLonLat(){
  // use controls.target for center
  const tx = controls.target.x;
  const tz = controls.target.z;
  const m = worldToMerc(tx, tz, ORIGIN_M);
  return { lon: mercXToLon(m.x), lat: mercYToLat(m.y) };
}

function lonToTileX(lon, zoom){ return Math.floor((lon + 180) / 360 * Math.pow(2,zoom)); }
function latToTileY(lat, zoom){
  const a = Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180));
  return Math.floor((1 - a/Math.PI) / 2 * Math.pow(2,zoom));
}

/* ===========================
   Tile update loop
   =========================== */
let lastUpdate = 0;
const MIN_UPDATE_INTERVAL = 1200;
async function updateTilesAroundCamera(){
  const now = performance.now();
  if(now - lastUpdate < MIN_UPDATE_INTERVAL) return;
  lastUpdate = now;

  const center = cameraToLonLat();
  const cx = lonToTileX(center.lon, ZOOM);
  const cy = latToTileY(center.lat, ZOOM);

  unloadFarTiles(cx, cy);

  for(let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++){
    for(let dy = -LOAD_RADIUS; dy <= LOAD_RADIUS; dy++){
      const tx = cx + dx, ty = cy + dy;
      const key = `${tx}_${ty}`;
      if(loadedTiles.has(key)){
        loadedTiles.get(key).lastUsed = Date.now();
        continue;
      }
      enqueueFetch(async ()=> {
        const res = await fetchOverpassForTile(tx, ty, ZOOM);
        if(res) addTileToScene(tx, ty, ZOOM, res);
        return res;
      });
    }
  }
}

/* ===========================
   Animation loop
   =========================== */
function animate(){
  requestAnimationFrame(animate);
  controls.update();

  // update LODs
  for(const [, info] of loadedTiles){
    info.group.traverse(obj=>{
      if(obj instanceof THREE.LOD) obj.update(camera);
    });
  }

  updateTilesAroundCamera();
  renderer.render(scene, camera);
}
animate();

/* resize */
window.addEventListener('resize', ()=> {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* keyboard radius */
window.addEventListener('keydown', (e)=>{
  if(e.key === "+"){ LOAD_RADIUS = Math.min(4, LOAD_RADIUS+1); document.getElementById('rad').textContent = LOAD_RADIUS; }
  if(e.key === "-"){ LOAD_RADIUS = Math.max(0, LOAD_RADIUS-1); document.getElementById('rad').textContent = LOAD_RADIUS; }
});

/* start queue processor */
processQueue();

console.log("Alignment-fix Dynamic OSM viewer started.");
</script>
</body>
</html>
