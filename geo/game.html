<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>3D Map Game with Joystick</title>
<style>
body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
#info{
  position:absolute;left:10px;top:10px;z-index:20;
  background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px;
}
/* ジョイスティックUI */
#joystick{
  position: absolute;
  bottom: 40px;
  left: 40px;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(200,200,200,0.3);
  touch-action: none;
  z-index: 15;
}
#stick{
  position: absolute;
  width: 60px;
  height: 60px;
  left: 30px;
  top: 30px;
  border-radius: 50%;
  background: rgba(100,100,100,0.6);
}
</style>
</head>
<body>
<div id="info">ドラッグで視点操作 / 左下で移動</div>
<div id="joystick"><div id="stick"></div></div>

<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
<script>
/* ===================== Three.js 初期化 ===================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 800, 1200);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir = new THREE.DirectionalLight(0xffffff,0.9);
dir.position.set(500,1000,500);
scene.add(dir);

/* ===================== 簡易マップ床 ===================== */
const floorGeo = new THREE.PlaneGeometry(2000,2000);
const floorMat = new THREE.MeshPhongMaterial({color:0x999966});
const floor = new THREE.Mesh(floorGeo,floorMat);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ===================== キャラクター ===================== */
const playerGeo = new THREE.CapsuleGeometry(15,40,4,8);
const playerMat = new THREE.MeshPhongMaterial({color:0xff5555});
const player = new THREE.Mesh(playerGeo,playerMat);
player.position.y=30;
scene.add(player);

/* ===================== Joystick ===================== */
let joystickDir = new THREE.Vector3();
const joystick = document.getElementById('joystick');
const stick = document.getElementById('stick');
let activeTouch = null;

joystick.addEventListener('touchstart', e=>{
  activeTouch = e.changedTouches[0].identifier;
});
joystick.addEventListener('touchmove', e=>{
  if(activeTouch===null) return;
  for(const t of e.changedTouches){
    if(t.identifier!==activeTouch) continue;
    const rect = joystick.getBoundingClientRect();
    let dx = t.clientX - (rect.left + rect.width/2);
    let dy = t.clientY - (rect.top + rect.height/2);
    const maxDist = rect.width/2;
    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxDist);
    const angle = Math.atan2(dy, dx);
    dx = Math.cos(angle)*dist;
    dy = Math.sin(angle)*dist;
    stick.style.transform = `translate(${dx}px, ${dy}px)`;
    // 上下反転: 上にドラッグで前進
    joystickDir.set(dx/maxDist,0,dy/maxDist*-1);
  }
});
joystick.addEventListener('touchend', e=>{
  for(const t of e.changedTouches){
    if(t.identifier===activeTouch){
      activeTouch=null;
      stick.style.transform = `translate(0px,0px)`;
      joystickDir.set(0,0,0);
    }
  }
});

/* ===================== 移動ループ ===================== */
const speed = 4;
function updatePlayer(){
  if(joystickDir.length()>0.1){
    // カメラ後方視点: カメラのY回転を反映
    const camYaw = Math.atan2(camera.position.x-player.position.x, camera.position.z-player.position.z);
    const cosR = Math.cos(camYaw), sinR = Math.sin(camYaw);
    const moveX = joystickDir.x*cosR - joystickDir.z*sinR;
    const moveZ = joystickDir.x*sinR + joystickDir.z*cosR;
    player.position.x += moveX*speed;
    player.position.z += moveZ*speed;
    // プレイヤーの向き
    player.rotation.y = Math.atan2(moveX, moveZ);
    // カメラ追従
    camera.position.x = player.position.x - 300*Math.sin(player.rotation.y);
    camera.position.z = player.position.z - 300*Math.cos(player.rotation.y);
    camera.position.y = player.position.y + 150;
    controls.target.set(player.position.x, player.position.y+20, player.position.z);
  }
}

/* ===================== アニメーション ===================== */
function animate(){
  requestAnimationFrame(animate);
  updatePlayer();
  controls.update();
  renderer.render(scene,camera);
}
animate();

/* ===================== Resize ===================== */
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
