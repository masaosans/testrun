<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>3D Game Camera Control</title>
<style>
body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
#info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px;}
#joystick{
  position: absolute;
  bottom: 60px; left: 60px;
  width: 120px; height: 120px;
  border-radius: 50%; background: rgba(200,200,200,0.3);
  touch-action: none; z-index: 15;
}
#stick{
  position: absolute;
  width: 60px; height: 60px;
  left: 30px; top: 30px;
  border-radius: 50%; background: rgba(100,100,100,0.6);
  touch-action: none;
}
</style>
</head>
<body>
<div id="info">ドラッグで視点操作 / 左下で移動</div>
<div id="joystick"><div id="stick"></div></div>

<script src="https://unpkg.com/three@0.145.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
<script>
/* ===================== Three.js 初期化 ===================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 200, 500);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.enablePan = false;
controls.enableZoom = false;

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir = new THREE.DirectionalLight(0xffffff,0.9);
dir.position.set(500,1000,500);
scene.add(dir);

/* ===================== 床 ===================== */
const floorGeo = new THREE.PlaneGeometry(2000,2000);
const floorMat = new THREE.MeshPhongMaterial({color:0x999966});
const floor = new THREE.Mesh(floorGeo,floorMat);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ===================== キャラクター ===================== */
const playerGeo = new THREE.CapsuleGeometry(15,40,4,8);
const playerMat = new THREE.MeshPhongMaterial({color:0xff5555});
const player = new THREE.Mesh(playerGeo,playerMat);
player.position.y=30;
scene.add(player);

/* ===================== Joystick ===================== */
let joystickDir = new THREE.Vector2();
const joystick = document.getElementById('joystick');
const stick = document.getElementById('stick');
let activeTouch = null;

function handleTouchStart(e){ activeTouch = e.changedTouches[0].identifier; }
function handleTouchMove(e){
  if(activeTouch===null) return;
  for(const t of e.changedTouches){
    if(t.identifier!==activeTouch) continue;
    const rect = joystick.getBoundingClientRect();
    let dx = t.clientX - (rect.left + rect.width/2);
    let dy = t.clientY - (rect.top + rect.height/2);
    const maxDist = rect.width/2;
    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxDist);
    const angle = Math.atan2(dy, dx);
    dx = Math.cos(angle)*dist;
    dy = Math.sin(angle)*dist;
    stick.style.transform = `translate(${dx}px, ${dy}px)`;
    joystickDir.set(dx/maxDist, -dy/maxDist); // 上で前進
  }
}
function handleTouchEnd(e){
  for(const t of e.changedTouches){
    if(t.identifier===activeTouch){
      activeTouch=null;
      stick.style.transform = `translate(0px,0px)`;
      joystickDir.set(0,0);
    }
  }
}

joystick.addEventListener('touchstart', handleTouchStart);
joystick.addEventListener('touchmove', handleTouchMove);
joystick.addEventListener('touchend', handleTouchEnd);
joystick.addEventListener('touchcancel', handleTouchEnd);

/* ===================== 移動 ===================== */
const speed = 4;
const camOffset = new THREE.Vector3(0,150,-300);

function updatePlayer(delta){
  if(joystickDir.length() > 0.1){
    // カメラの水平角を基準に前方ベクトルを作る
    const camYaw = Math.atan2(camera.position.x - player.position.x, camera.position.z - player.position.z);
    const moveDir = new THREE.Vector3(joystickDir.x, 0, joystickDir.y);
    moveDir.applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
    player.position.add(moveDir.multiplyScalar(speed));
    // キャラクターの向きを移動方向に回転
    player.rotation.y = Math.atan2(moveDir.x, moveDir.z);
  }

  // カメラ滑らか追従
  const desiredCamPos = player.position.clone().add(camOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), 0));
  camera.position.lerp(desiredCamPos, 0.1);
  controls.target.lerp(player.position.clone().add(new THREE.Vector3(0,20,0)),0.1);
}

/* ===================== アニメーション ===================== */
let lastTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = (now-lastTime)/1000;
  lastTime=now;

  updatePlayer(delta);
  controls.update();
  renderer.render(scene,camera);
}
animate();

/* ===================== Resize ===================== */
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
