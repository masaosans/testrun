<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>3D街中キャラクター移動サンプル</title>
<style>
body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
#info{
  position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);
  padding:8px;border-radius:6px;font-size:13px
}
</style>
</head>
<body>
<div id="info">
ドラッグで視点調整 / WASDで移動（PC） / スマホはタッチで移動
</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===================== 初期化 ===================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 10, 20);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir = new THREE.DirectionalLight(0xffffff,0.9);
dir.position.set(50,100,50);
scene.add(dir);

/* ===================== 簡易マップ生成 ===================== */
// 無料OSMタイルの代わりに簡易ブロックで街を作る
const mapGroup = new THREE.Group();
scene.add(mapGroup);

const mapSize = 20; // 20x20マス
for(let x=-mapSize/2;x<mapSize/2;x++){
  for(let z=-mapSize/2;z<mapSize/2;z++){
    const h = Math.random()*5 + 2; // 建物高さ
    const geo = new THREE.BoxGeometry(1, h,1);
    const mat = new THREE.MeshStandardMaterial({color:0x999999});
    const b = new THREE.Mesh(geo, mat);
    b.position.set(x*2 + 1, h/2, z*2 +1);
    mapGroup.add(b);
  }
}

// 床
const floorGeo = new THREE.PlaneGeometry(mapSize*2*2, mapSize*2*2);
const floorMat = new THREE.MeshStandardMaterial({color:0xcccccc});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* ===================== キャラクター ===================== */
const playerGeo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
const playerMat = new THREE.MeshStandardMaterial({color:0xff0000});
const player = new THREE.Mesh(playerGeo, playerMat);
player.position.set(0,1,0);
scene.add(player);

/* ===================== カメラ追従 ===================== */
const cameraOffset = new THREE.Vector3(0,6,12);
function updateCamera(){
  const desired = player.position.clone().add(cameraOffset);
  camera.position.lerp(desired, 0.1);
  camera.lookAt(player.position);
}

/* ===================== キャラクター操作 ===================== */
const keys = {};
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()]=false);

function updatePlayer(delta){
  const speed = 5 * delta;
  let dir = new THREE.Vector3();
  if(keys['w']) dir.z -=1;
  if(keys['s']) dir.z +=1;
  if(keys['a']) dir.x -=1;
  if(keys['d']) dir.x +=1;
  if(dir.length()>0){
    dir.normalize();
    // camera基準で方向調整
    const angle = Math.atan2(camera.position.x - player.position.x, camera.position.z - player.position.z);
    dir.applyAxisAngle(new THREE.Vector3(0,1,0), angle);
    player.position.addScaledVector(dir, speed);
  }
}

/* ===================== アニメーション ===================== */
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = (now - prevTime)/1000;
  prevTime = now;

  updatePlayer(delta);
  updateCamera();

  controls.update();
  renderer.render(scene, camera);
}
animate();

/* ===================== リサイズ ===================== */
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* ===================== スマホ操作用（仮想ジョイスティック） ===================== */
let touchStartX=0, touchStartY=0, touchDir = new THREE.Vector3();
window.addEventListener('touchstart', e=>{
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
});
window.addEventListener('touchmove', e=>{
  const t = e.touches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  touchDir.set(dx,0,-dy).normalize();
});
window.addEventListener('touchend', e=>{
  touchDir.set(0,0,0);
});

function updatePlayerTouch(delta){
  const speed = 5*delta;
  player.position.addScaledVector(touchDir,speed);
}

// 既存の updatePlayer() に統合
function updatePlayer(delta){
  const speed = 5 * delta;
  let dir = new THREE.Vector3();
  if(keys['w']) dir.z -=1;
  if(keys['s']) dir.z +=1;
  if(keys['a']) dir.x -=1;
  if(keys['d']) dir.x +=1;
  dir.add(touchDir); // タッチ方向追加
  if(dir.length()>0){
    dir.normalize();
    const angle = Math.atan2(camera.position.x - player.position.x, camera.position.z - player.position.z);
    dir.applyAxisAngle(new THREE.Vector3(0,1,0), angle);
    player.position.addScaledVector(dir, speed);
  }
}
</script>
</body>
</html>
