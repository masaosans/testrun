<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>OSM 3D Viewer (Aligned Fix) - Extrude alignment</title>
<style>
/* CSS */
body{
    margin:0;
    overflow:hidden;
    font-family:Arial,Helvetica;
}
#info{
    position:absolute;
    left:10px;
    top:10px;
    z-index:20;
    background:rgba(255,255,255,0.9);
    padding:8px;
    border-radius:6px;
    font-size:13px
}
#mapButton {
  position: absolute;
  top: 15px;
  left: 15px;
  padding: 12px 24px;         /* ボタンサイズ */
  font-size: 16px;            /* 文字サイズ */
  font-weight: 600;
  color: #ffffff;             /* 文字色 */
  background-color: #4CAF50;  /* 緑色 */
  border: none;               /* 枠線なし */
  border-radius: 8px;         /* 角丸 */
  box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* 軽い影 */
  cursor: pointer;
  transition: all 0.2s ease;  /* ホバー時のアニメーション */
  z-index: 100; /* ミニマップより上に */
}

/* ホバー時 */
#mapButton:hover {
  background-color: #45a049;
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
  transform: translateY(-2px); /* 少し浮く */
}

/* タッチ端末でも押しやすく */
#mapButton:active {
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  transform: translateY(0);
}

/* ミニマップ */
#miniMap {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 50;
  display: none;
  background: rgba(255, 255, 255, 0.9);
}
/* ジョイスティック操作領域 */
#joystick-zone {
  position: absolute;
  left: 20px;
  bottom: 20px;
  width: 120px;   /* 大きめに */
  height: 120px;
  z-index: 1000;
}
</style>
</head>
<body>
<div id="info">
  ドラッグで移動 / ホイールでズーム。Tile Z=16, radius = <span id="rad">1</span>
</div>
<button id="mapButton">日本地図</button>
<canvas id="miniMap"></canvas>
<div id="joystick-zone"></div>

<!-- Three.js と OrbitControls 読み込み -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.0/dist/nipplejs.min.js"></script>
<script>
/* ============================================================================
   基本設定値
   ============================================================================ */

/*
  ZOOM: 使用する地図タイルのズームレベル。
  OSM タイルは z=16 付近で建物位置が比較的安定。  
  数字を大きくすると詳細になるがタイル負荷が増える。
*/
const ZOOM = 16;

/*
  LOAD_RADIUS:
    - カメラ中心から何タイル分の範囲を読み込むかを指定。
    - 数字を増やすと広い範囲をロードするが Overpass の負荷・描画負荷が増える
*/
let LOAD_RADIUS = 1;
document.getElementById('rad').textContent = LOAD_RADIUS;

/*
  同時に実行するフェッチ数
  Overpass API の負荷軽減のために制限している
*/
const MAX_CONCURRENT_FETCH = 3;

/*
  Overpass API 失敗時のリトライ回数
*/
const OVERPASS_RETRY = 2;

/*
  Overpass API 呼び出しの間隔(ms)。  
  API 負荷を下げつつタイリングを行うためのディレイ。
*/
const OVERPASS_DELAY_MS = 300;

/* Overpass API のエンドポイント URL */
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";


/* ============================================================================
   WebMercator / タイル座標計算
   OSMもGoogle Mapも WebMercator で統一されている座標変換部分
   ============================================================================ */

// 地球半径（WebMercator で使用）
const R = 6378137;

// 度 <-> ラジアン変換
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

// 経度→メルカトル x
function lonToMercX(lon){ return R * deg2rad(lon); }

// 緯度→メルカトル y（OSM / Google と同じ式）
function latToMercY(lat){ return R * Math.log(Math.tan(Math.PI/4 + deg2rad(lat)/2)); }

// メルカトル x,y → 経度・緯度
function mercXToLon(x){ return rad2deg(x / R); }
function mercYToLat(y){ return rad2deg(2 * Math.atan(Math.exp(y / R)) - Math.PI/2); }

// 経度緯度 → メルカトル座標
function lonLatToMerc(lon, lat){ return { x: lonToMercX(lon), y: latToMercY(lat) }; }

// タイル番号 → 経度緯度の範囲を求める
function tile2lon(x,z){ return x / Math.pow(2,z) * 360 - 180; }
function tile2lat(y,z){
    const n = Math.PI - 2 * Math.PI * y / Math.pow(2,z);
    return Math.atan(Math.sinh(n)) * 180 / Math.PI;
}

// 経度緯度 → タイル番号
function lonToTileX(lon, zoom){ return Math.floor((lon+180)/360*Math.pow(2,zoom)); }
function latToTileY(lat, zoom){
    const a = Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180));
    return Math.floor((1 - a/Math.PI)/2*Math.pow(2,zoom));
}


/* ============================================================================
   原点座標の設定（カメラの中心基準）
   ============================================================================ */

/*
  描画空間のズレを減らすため  
  初期中心（東京付近）を原点(0,0)扱いに変換する。
*/
const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT);


/* ============================================================================
   Three.js 初期化
   ============================================================================ */
// 描画レンダラー
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// シーン作成
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb); // 空色背景

// カメラ作成
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 400, 600);

// マウス操作（OrbitControls）
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

// ライト
scene.add(new THREE.AmbientLight(0xffffff, 0.6)); // 環境光
const dir = new THREE.DirectionalLight(0xffffff, 0.9); // 太陽光
dir.position.set(500,1000,500);
scene.add(dir);


/* ============================================================================
   キャッシュ管理
   ============================================================================ */

// 読み込んだタイルのキャッシュ
const loadedTiles = new Map();

// フェッチ待ちキュー
const fetchQueue = [];
let activeFetches = 0;

// OSM 建物 JSON キャッシュ
const geoCache = new Map();

// OSM 画像キャッシュ
const imgCache = new Map();

// 壁のテクスチャ（お好みで変更可）
const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");


/* ============================================================================
   タイル（1枚の画像）の経度緯度範囲を求める
   ============================================================================ */
function tileBBoxLonLat(x,y,z){
    return {
        west: tile2lon(x,z),
        north: tile2lat(y,z),
        east: tile2lon(x+1,z),
        south: tile2lat(y+1,z)
    };
}

function bboxToOverpassQuery(bbox){
    /*
      指定したタイル範囲の中の building=*
      の way を Overpass API で取得
    */
    return `[out:json][timeout:25];
      (way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east}););
      (._;>;);
      out geom;`;
}


/* ============================================================================
   フェッチキュー処理
   ============================================================================ */

/*
  Overpass API への問い合わせ  
  リトライ込みの安全版実装
*/
async function fetchOverpassForTile(x,y,z, tries=0){
    const key = `${x}_${y}`;
    if(geoCache.has(key)) return geoCache.get(key);

    const bbox = tileBBoxLonLat(x,y,z);
    const query = bboxToOverpassQuery(bbox);

    try {
        activeFetches++;
        const res = await fetch(OVERPASS_URL, {method:"POST", body:query});
        if(!res.ok) throw new Error(`HTTP ${res.status}`);

        const json = await res.json();
        const data = { bbox, json };
        geoCache.set(key, data);
        return data;
    } catch(err){
        if(tries < OVERPASS_RETRY){
            await new Promise(r=>setTimeout(r,500*Math.pow(2,tries)));
            return fetchOverpassForTile(x,y,z,tries+1);
        } else return null;
    } finally {
        activeFetches--;
    }
}

/*
  フェッチ処理をキューに追加
*/
function enqueueFetch(fn){
    return new Promise(resolve=>{
        fetchQueue.push({fn,resolve});
        processQueue();
    });
}

/*
  フェッチキューを逐次処理  
  同時リクエスト数を制御する
*/
function processQueue(){
    if(activeFetches>=MAX_CONCURRENT_FETCH) return;
    const job = fetchQueue.shift(); 
    if(!job) return;

    job.fn().then(r=>job.resolve(r))
        .finally(()=>setTimeout(processQueue, OVERPASS_DELAY_MS));
}


/* ============================================================================
   床タイルの描画（OSM の画像をそのまま貼る）
   ============================================================================ */

function addFloorMeshToGroup(tex, bbox, group){
    /*
      タイルの経度緯度範囲をメルカトル→ワールド座標に変換し
      1枚の Plane として描画
    */
    const westMx = lonToMercX(bbox.west);
    const eastMx = lonToMercX(bbox.east);
    const northMy = latToMercY(bbox.north);
    const southMy = latToMercY(bbox.south);

    const mercW = eastMx - westMx;
    const mercH = northMy - southMy;

    const centerX = (westMx + eastMx)/2 - ORIGIN_M.x;
    const centerZ = -((southMy + northMy)/2 - ORIGIN_M.y);

    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(mercW, mercH),
        new THREE.MeshPhongMaterial({ map: tex, side: THREE.DoubleSide })
    );

    // OSM タイル画像は通常上下反転しているためθ=-90°
    plane.rotation.x = -Math.PI/2;

    plane.position.set(centerX, 0, centerZ);
    group.add(plane);
}


/* ============================================================================
   建物（Extrude / Box 共通）座標変換
   ============================================================================ */

/* メルカトル座標 → Three.js 用の XY平面→XZ平面変換 */
function mercToWorld(mx, my){
    return { x: mx - ORIGIN_M.x, z: -(my - ORIGIN_M.y) };
}


/* ============================================================================
   Extrude 版の建物生成（詳細LOD）
   ============================================================================ */

/*
    createExtrudeMeshFromWay:
    - 建物の輪郭を extrude して立体化する
    - createBoxLODFromWay と位置合わせのため
      中心位置を同じ計算法で揃えている
*/
function createExtrudeMeshFromWay(el){
    // geometry がなければ建物は作れない
    if(!el || !el.geometry || !Array.isArray(el.geometry) || el.geometry.length < 3) return null;

    // world 座標に変換し、同時に bbox を求める
    let minX = Infinity, minZ = Infinity, maxX = -Infinity, maxZ = -Infinity;
    const worldPts = [];

    for(const pt of el.geometry){
        const m = lonLatToMerc(pt.lon, pt.lat);
        const w = mercToWorld(m.x, m.y);
        worldPts.push(w);

        if(w.x < minX) minX = w.x;
        if(w.x > maxX) maxX = w.x;
        if(w.z < minZ) minZ = w.z;
        if(w.z > maxZ) maxZ = w.z;
    }

    if(worldPts.length < 3) return null;

    // BoxLOD と同じ中心の取り方
    const cx = (minX + maxX)/2;
    const cz = (minZ + maxZ)/2;

    // ローカル座標の Shape を作成
    const shape = new THREE.Shape();
    for(let i=0;i<worldPts.length;i++){
        const p = worldPts[i];
        const lx = p.x - cx;
        const lz = p.z - cz;
        if(i===0) shape.moveTo(lx, lz);
        else shape.lineTo(lx, lz);
    }

    // 建物の高さ（タグがあれば優先）
    const tags = el.tags || {};
    let height = 10;
    if(tags.height) height = parseFloat(String(tags.height).replace('m',''))||height;
    else if(tags["building:levels"]) height = (parseFloat(tags["building:levels"])||1)*3;

    // Extrude（Z方向が縦になるため X 回転を後で加える）
    const geo = new THREE.ExtrudeGeometry(shape, {
        depth: height,
        bevelEnabled:false,
        curveSegments: 1
    });

    geo.rotateX(-Math.PI/2);

    // Center を 0 にそろえる → Box と位置が一致するため
    geo.computeBoundingBox();
    const minY = geo.boundingBox.min.y;
    const maxY = geo.boundingBox.max.y;
    const centerY = (minY + maxY) / 2;
    geo.translate(0, -centerY, 0);

    // 壁材（写真などに変えればリアル化可能）
    const mat = new THREE.MeshPhongMaterial({
        map: windowTex,
        color:0x999999
    });

    //追加
    const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x999999, // 明るい壁色
        roughness: 0.9,
        metalness: 0.0
    });

    const roofMaterial = new THREE.MeshStandardMaterial({
        color: 0x999999, // 明るい屋根色
        roughness: 0.9,
        metalness: 0.0
    });
    
    //const mesh = new THREE.Mesh(geo, mat);
　  const mesh = new THREE.Mesh(geo, [wallMaterial, roofMaterial]);
    mesh.castShadow = true;
    mesh.receiveShadow = true;


    // BoxLOD と同じ配置になるよう高さ/2 を足す
    mesh.position.set(cx, height/2, cz);

    return mesh;
}


/* ============================================================================
   Box 版低LODの建物（簡易ボックス）
   ============================================================================ */

function createBoxLODFromWay(el,height){
    let minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;

    // bbox を求める
    for(const pt of el.geometry){
        const m = lonLatToMerc(pt.lon, pt.lat);
        const w = mercToWorld(m.x, m.y);
        if(w.x<minX) minX=w.x;
        if(w.x>maxX) maxX=w.x;
        if(w.z<minZ) minZ=w.z;
        if(w.z>maxZ) maxZ=w.z;
    }

    const sx = Math.max(1, maxX - minX);
    const sz = Math.max(1, maxZ - minZ);
    const cx = (minX + maxX)/2;
    const cz = (minZ + maxZ)/2;

    const geo = new THREE.BoxGeometry(sx,height,sz);
    const mat = new THREE.MeshPhongMaterial({color:0x999999});
    const box = new THREE.Mesh(geo, mat);

    // BoxGeometry は中心が 0,0,0 → 建物底面を 0 にするため height/2
    box.position.set(cx, height/2, cz);

    return box;
}


/* ============================================================================
   建物LOD をまとめて作成（Extrude + 低LOD Box）
   ============================================================================ */

function createBuildingLOD(el){
    const tags = el.tags||{};
    if(!tags.building) return null;

    // 高さの計算
    let height = 10;
    if(tags.height) height = parseFloat(String(tags.height).replace('m',''))||height;
    else if(tags["building:levels"]) height = (parseFloat(tags["building:levels"])||1)*3;

    const lod = new THREE.LOD();

    // ★ 建物の名称を保存（追加）
    lod.userData.name = tags.name || null;
    lod.userData.height = height;

    // LOD0: 詳細 Extrude
    try{
        const extrude = createExtrudeMeshFromWay(el);
        if(extrude) lod.addLevel(extrude,0);
    } catch(e){ console.warn("detail fail",e); }

    // LOD1, LOD2: 遠距離は Box
    const box1 = createBoxLODFromWay(el,Math.max(3,height*0.9));
    const box2 = createBoxLODFromWay(el,Math.max(3,height*0.7));

    if(box1) lod.addLevel(box1,3000);
    if(box2) lod.addLevel(box2,5000);

    return lod;
}


/* ============================================================================
   タイル1枚を Three.js シーンに追加
   ============================================================================ */

function addTileToScene(x,y,z,data){
    const key = `${x}_${y}`;
    if(loadedTiles.has(key)) return;

    const group = new THREE.Group();
    group.userData={x,y,z,bbox:data.bbox};

    // ========== 床タイル画像 ==========
    const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;

    if(imgCache.has(tileUrl)){
        addFloorMeshToGroup(imgCache.get(tileUrl), data.bbox, group);
    } else {
        new THREE.TextureLoader().load(tileUrl, tex=>{
            tex.flipY = true;
            imgCache.set(tileUrl, tex);
            addFloorMeshToGroup(tex, data.bbox, group);
        });
    }

    // ========== 建物 ==========
    const els = data.json.elements||[];
    for(const el of els){
        if(el.type!=="way"||!el.geometry) continue;
        try{
            const b = createBuildingLOD(el);
            if(b) group.add(b);
        } catch(e){ console.warn("building create err",e); }
    }

    scene.add(group);
    loadedTiles.set(key,{group,lastUsed:Date.now(),bbox:data.bbox});
    console.log(`Tile added ${key} (features: ${els.length})`);
}


/* ============================================================================
   タイルのアンロード（範囲外を削除してメモリ開放）
   ============================================================================ */

function unloadFarTiles(cx,cy){
    for(const [key,info] of Array.from(loadedTiles)){
        const [tx,ty] = key.split("_").map(n=>parseInt(n,10));

        // 表示範囲外なら削除
        if(Math.abs(tx-cx)>LOAD_RADIUS+1 || Math.abs(ty-cy)>LOAD_RADIUS+1){
            const grp = info.group;
            scene.remove(grp);

            grp.traverse(obj=>{
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material)
                    Array.isArray(obj.material)
                    ? obj.material.forEach(m=>m.dispose())
                    : obj.material.dispose();
            });

            loadedTiles.delete(key);
            console.log(`Tile unloaded ${key}`);
        }
    }
}


/* ====================================================================
   建物名称ラベル（Sprite で表示）
==================================================================== */
function makeTextSprite(message) {
    const fontSize = 48;

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.font = `${fontSize}px sans-serif`;

    const textWidth = ctx.measureText(message).width;
    canvas.width = textWidth + 40;
    canvas.height = fontSize + 40;

    ctx.font = `${fontSize}px sans-serif`;
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#fff";
    ctx.fillText(message, 20, fontSize + 10);

    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);

    sprite.scale.set(canvas.width * 0.5, canvas.height * 0.5, 1);

    return sprite;
}

let currentLabel = null;
let hideLabelTimer = null;

function showBuildingLabel(name, worldPos) {
    if (currentLabel) {
        scene.remove(currentLabel);
        currentLabel = null;
    }

    currentLabel = makeTextSprite(name);
    currentLabel.position.copy(worldPos);
    scene.add(currentLabel);

    if (hideLabelTimer) clearTimeout(hideLabelTimer);

    hideLabelTimer = setTimeout(()=>{
        if(currentLabel){
            scene.remove(currentLabel);
            currentLabel = null;
        }
    }, 2500);
}

/* ====================================================================
   建物クリック検出（Raycaster）
==================================================================== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function getMousePosition(e){
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width ) * 2 - 1;
    mouse.y = -((e.clientY - rect.top ) / rect.height) * 2 + 1;
}

function handleBuildingClick(){
    raycaster.setFromCamera(mouse, camera);

    // 全タイルの全 LOD を対象にする
    const objects = [];
    for(const [_, info] of loadedTiles){
        info.group.traverse(obj=>{
            if(obj instanceof THREE.LOD){
                objects.push(obj);
            }
        });
    }

    const hits = raycaster.intersectObjects(objects, true);
    if(hits.length === 0) return;

    let obj = hits[0].object;
    while(obj && !(obj instanceof THREE.LOD)){
        obj = obj.parent;
    }
    if(!obj) return;

    const name = obj.userData.name;
    if(!name) return;

    const height = obj.userData.height || 10;

//
   // ★ 修正: LOD内の実際のメッシュ位置を取得
    let targetMesh = hits[0].object; // タップした正確なメッシュ
    const pos = new THREE.Vector3();
    targetMesh.getWorldPosition(pos); // ワールド座標取得

    // 建物の上に十分余裕を持たせる (+ height*0.6)
    //const pos = new THREE.Vector3();
    //obj.getWorldPosition(pos);
 //   pos.y += height * 0.6 + 10;
    pos.y += height + 5;

    showBuildingLabel(name, pos);
}

function onPointerDown(e) {
    e.preventDefault();

    let clientX, clientY;
    if(e.touches && e.touches.length > 0){
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }

    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((clientX - rect.left) / rect.width ) * 2 - 1;
    mouse.y = -((clientY - rect.top ) / rect.height) * 2 + 1;

    handleBuildingClick();
}

// マウスとタッチの両方に対応
renderer.domElement.addEventListener("click", onPointerDown);
renderer.domElement.addEventListener("touchstart", onPointerDown);



/* ============================================================================
   カメラの現在位置 → 経度緯度へ変換
   ============================================================================ */

function cameraToLonLat(){
    /*
      OrbitControls のターゲット位置（地面の中央）から  
      経度緯度に逆変換する
    */
    const tx = controls.target.x;
    const tz = controls.target.z;

    const m = {
        x: tx + ORIGIN_M.x,
        y: -(tz) + ORIGIN_M.y
    };
    return {
        lon: mercXToLon(m.x),
        lat: mercYToLat(m.y)
    };
}


/* ============================================================================
   タイル更新ループ
   ============================================================================ */

let lastUpdate=0;
const MIN_UPDATE_INTERVAL=1200; // 最小更新間隔(ms)

async function updateTilesAroundCamera(){
    const now = performance.now();
    if(now - lastUpdate < MIN_UPDATE_INTERVAL) return;
    lastUpdate = now;

    // カメラ中心タイル
    const center = cameraToLonLat();
    const cx = lonToTileX(center.lon, ZOOM);
    const cy = latToTileY(center.lat, ZOOM);

    // 古いタイルをアンロード
    unloadFarTiles(cx, cy);

    // 周囲 LOAD_RADIUS のタイルをロード
    for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
        for(let dy=-LOAD_RADIUS; dy<=LOAD_RADIUS; dy++){
            const tx=cx+dx, ty=cy+dy;
            const key=`${tx}_${ty}`;

            if(loadedTiles.has(key)){
                loadedTiles.get(key).lastUsed=Date.now();
                continue;
            }

            enqueueFetch(async()=>{
                const res = await fetchOverpassForTile(tx, ty, ZOOM);
                if(res) addTileToScene(tx, ty, ZOOM, res);
                return res;
            });
        }
    }
}

/* ============================================================================
   ジョイスティックの追加
   ============================================================================ */
const joystick = nipplejs.create({
    zone: document.getElementById('joystick-zone'), // 操作範囲を限定
    mode: 'static',           // 常に同じ位置に表示
    position: { left: '80px', bottom: '80px' },
    color: 'blue',
    size: 80
});

let moveX = 0;
let moveZ = 0;

//ジョイスティックとカメラの方向を合わせる
joystick.on('move', (evt, data) => {
    if(!data) return;

    const force = data.force; // 力の大きさ（0～1）
    const angle = data.angle.radian; // ラジアン

　//下記だと動きがあっていないため、左右と前後を入れ替え（sincos入れ替え）、左と右を入れ替え（-を追加）
 //   moveX = Math.sin(angle) * force * 5; // 左右
 //   moveZ = Math.cos(angle) * force * 5; // 前後    
    moveX = Math.cos(angle) * force * -5; // 左右
    moveZ = Math.sin(angle) * force * 5; // 前後

});

joystick.on('end', () => {
    moveX = 0;
    moveZ = 0;
});


/* ============================================================================
   メイン描画ループ（アニメーション）
   ============================================================================ */

function animate(){
    requestAnimationFrame(animate);

    controls.update();

    // 建物LODをカメラ距離に合わせて更新
    for(const [,info] of loadedTiles){
        info.group.traverse(obj=>{
            if(obj instanceof THREE.LOD)
                obj.update(camera);
        });
    }

    // カメラ移動（ジョイスティック）
    if(moveX !== 0 || moveZ !== 0){
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        
        // カメラの向きに合わせて前後移動
        const forward = new THREE.Vector3(dir.x, 0, dir.z).normalize();
        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();

        camera.position.add(forward.clone().multiplyScalar(moveZ));
        camera.position.add(right.clone().multiplyScalar(moveX));

        // OrbitControls のターゲットも同じだけ移動
        controls.target.add(forward.clone().multiplyScalar(moveZ));
        controls.target.add(right.clone().multiplyScalar(moveX));
    }

    updateTilesAroundCamera();
    renderer.render(scene,camera);
}
animate();


/* ============================================================================
   ウィンドウサイズ変更対応
   ============================================================================ */
window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
});


/* ============================================================================
   キーボード：表示タイル半径の変更（+ / -）
   ============================================================================ */
window.addEventListener('keydown', e=>{
    if(e.key==="+"){
        LOAD_RADIUS=Math.min(4,LOAD_RADIUS+1);
        document.getElementById('rad').textContent=LOAD_RADIUS;
    }
    if(e.key==="-"){
        LOAD_RADIUS=Math.max(0,LOAD_RADIUS-1);
        document.getElementById('rad').textContent=LOAD_RADIUS;
    }
});


/* フェッチキューの処理開始 */
processQueue();
console.log("Aligned Dynamic OSM viewer started.");

/* ============================================================================
   ミニマップの描画処理
   ============================================================================ */
// ミニマップのキャンバス

const miniMap = document.getElementById("miniMap");
const ctx = miniMap.getContext("2d");

function resizeCanvas() {
    miniMap.width = window.innerWidth;
    miniMap.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// 緯度経度範囲（日本全体）
const latMax = 45.5, latMin = 24;
const lonMin = 122, lonMax = 153;

const geoUrl = "https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson";
let geoData = null;

fetch(geoUrl)
    .then(res => res.json())
    .then(json => {
        geoData = json;
        drawMap();
    });


/* ============================================================================
   線画での地図描画（初期定義）
   ============================================================================ */
// ★ 地図描画用の拡大縮小・オフセット
let mapScale = 1;
let mapOffsetX = 0;
let mapOffsetY = 0;

// ピンチ用
let lastDistance = 0;
let pinchCenterX = 0;
let pinchCenterY = 0;

//マーカー
let markerLon = null;
let markerLat = null;

//地図全体のメルカトル境界計算用
const mNW = lonLatToMercator(lonMin, latMax);
const mSE = lonLatToMercator(lonMax, latMin);

const mercLonMin = mNW.x;
const mercLatMax = mNW.y;
const mercLonMax = mSE.x;
const mercLatMin = mSE.y;

/* ============================================================================
   線画での地図描画（描画処理）
   ============================================================================ */
function drawMap() {
    if(!geoData) return;

    ctx.clearRect(0, 0, miniMap.width, miniMap.height);
    ctx.save();
    ctx.translate(mapOffsetX, mapOffsetY); // オフセット反映
    ctx.scale(mapScale, mapScale);         // 拡大縮小

    const cw = miniMap.width;
    const ch = miniMap.height;

    const lonRange = lonMax - lonMin;
    const latRange = latMax - latMin;
    const mapRatio = lonRange / latRange;
    const canvasRatio = cw / ch;

    let scale, xOffset=0, yOffset=0;
    if(canvasRatio > mapRatio){
        scale = ch / latRange;
        xOffset = (cw - scale * lonRange)/2;
    } else {
        scale = cw / lonRange;
        yOffset = (ch - scale * latRange)/2;
    }

    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1 / mapScale; // 線の太さ補正
    ctx.beginPath();

    geoData.features.forEach(feature => {
        const coordsArray = feature.geometry.coordinates;

        coordsArray.forEach(polygon => {
            polygon.forEach(ring => {
                ring.forEach((pt, i) => {
                    const m = lonLatToMercator(pt[0], pt[1]);

                    const x = xOffset + (m.x - mercLonMin) * scale;
                    const y = yOffset + (mercLatMax - m.y) * scale;

                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
            });
        });
    });

    ctx.stroke();
    // --- マーカー描画 ---
    if (markerLon !== null && markerLat !== null) {

        const cw = miniMap.width;
        const ch = miniMap.height;

        const lonRange = lonMax - lonMin;
        const latRange = latMax - latMin;
        const mapRatio = lonRange / latRange;
        const canvasRatio = cw / ch;

        let scale, xOffset=0, yOffset=0;
        if(canvasRatio > mapRatio){
            scale = ch / latRange;
            xOffset = (cw - scale * lonRange)/2;
        } else {
            scale = cw / lonRange;
            yOffset = (ch - scale * latRange)/2;
        }

        const sx = xOffset + (markerLon - lonMin) * scale;
        const sy = yOffset + (latMax - markerLat) * scale;

        const drawX = mapOffsetX + sx * mapScale;
        const drawY = mapOffsetY + sy * mapScale;

        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(drawX, drawY, 6, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
}
/* ============================================================================
   地図ボタン押下時の処理
   ============================================================================ */
const mapButton = document.getElementById("mapButton");
mapButton.addEventListener("click", () => {
    miniMap.style.display = miniMap.style.display === "none" ? "block" : "none";
});


/* ============================================================================
   マップクリック時の挙動
   ============================================================================ */

// ---- miniMap タップで移動＋マーカー設定 ----
miniMap.addEventListener("click", e => {
    const rect = miniMap.getBoundingClientRect();
    const clickX = (e.clientX - rect.left - mapOffsetX) / mapScale;
    const clickY = (e.clientY - rect.top  - mapOffsetY) / mapScale;

    const cw = miniMap.width;
    const ch = miniMap.height;
    const lonRange = lonMax - lonMin;
    const latRange = latMax - latMin;
    const mapRatio = lonRange / latRange;
    const canvasRatio = cw / ch;

    let scale, xOffset=0, yOffset=0;
    if(canvasRatio > mapRatio){
        scale = ch / latRange;
        xOffset = (cw - scale * lonRange)/2;
    } else {
        scale = cw / lonRange;
        yOffset = (ch - scale * latRange)/2;
    }

    const lon = lonMin + (clickX - xOffset) / scale;
    const lat = latMax - (clickY - yOffset) / scale;

    // ---- マーカー座標を保存 ----
    markerLon = lon;
    markerLat = lat;

    // ---- カメラ移動 ----
    const m = lonLatToMerc(lon, lat);
    const cameraHeight = camera.position.y;
    camera.position.set(m.x - ORIGIN_M.x, cameraHeight, -(m.y - ORIGIN_M.y));
    controls.target.set(m.x - ORIGIN_M.x, 0, -(m.y - ORIGIN_M.y));
    controls.update();
    updateTilesAroundCamera();

    drawMap();
    miniMap.style.display = "none";
});

/* ============================================================================
   マップのオブジェクトのみスワイプ拡大
   ============================================================================ */
// スマホのブラウザで画面拡大（スワイプでの拡大）しないように
miniMap.addEventListener('touchstart', e => {
    if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDistance = Math.hypot(dx, dy);

        pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX)/2;
        pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY)/2;
    }
}, { passive: false });

miniMap.addEventListener('touchmove', e => {
    if(e.touches.length === 2){
        e.preventDefault();

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.hypot(dx, dy);

        const scaleChange = distance / lastDistance;
        lastDistance = distance;

        // ピンチ中心に合わせてオフセットを補正
        mapOffsetX = pinchCenterX - (pinchCenterX - mapOffsetX) * scaleChange;
        mapOffsetY = pinchCenterY - (pinchCenterY - mapOffsetY) * scaleChange;

        mapScale *= scaleChange;
        mapScale = Math.min(Math.max(mapScale, 0.5), 5);

        drawMap();
    }
}, { passive: false });


/* ===============================
   メルカトル変換関数
================================ */
function lonLatToMercator(lon, lat){
    const x = lon;
    const y = Math.log(Math.tan(Math.PI/4 + (lat*Math.PI/180)/2)) * (180/Math.PI);
    return {x, y};
}

/* ===============================
   レスポンシブ対応
================================ */
function onWindowResize() {
    // Three.js canvas
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    // ミニマップのサイズ調整（幅の20%）
    const miniMap = document.getElementById("miniMap");
    miniMap.width = window.innerWidth * 0.25;
    miniMap.height = window.innerHeight * 0.25;

    // ジョイスティック（画面の15%）
    const joy = document.getElementById("joystick-zone");
    const size = Math.max(window.innerWidth, window.innerHeight) * 0.12;
    joy.style.width = size + "px";
    joy.style.height = size + "px";
}

window.addEventListener("resize", onWindowResize);
onWindowResize();

</script>
</body>
</html>
