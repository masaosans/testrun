<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>OSM 3D Viewer + TPS Character</title>
<style>
  body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}
  #info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px}
  #ui-left, #ui-right {
    position:absolute; bottom:20px; z-index:30; width:150px; height:150px;
    border-radius:50%; background:rgba(0,0,0,0.2);
    display:flex; align-items:center; justify-content:center;
  }
  #ui-left{ left:20px; }
  #ui-right{ right:20px; }
  #jumpBtn {
    position:absolute; bottom:200px; right:40px; z-index:30;
    width:60px; height:60px; border-radius:30px;
    background:rgba(255,255,255,0.7); font-size:16px; font-weight:bold; text-align:center; line-height:60px;
    cursor:pointer;
  }
</style>
</head>
<body>
<div id="info">
  „Éâ„É©„ÉÉ„Ç∞„Åß„Ç´„É°„É©Êìç‰Ωú / Â∑¶„Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅßÁßªÂãï / „Ç∏„É£„É≥„Éó„Éú„Çø„É≥„Åß„Ç∏„É£„É≥„Éó
</div>
<div id="ui-left">üïπÔ∏è</div>
<div id="ui-right"></div>
<div id="jumpBtn">‚Üë</div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===================== Ë®≠ÂÆö ===================== */
const ZOOM = 16;
let LOAD_RADIUS = 1;
const MAX_CONCURRENT_FETCH = 3;
const OVERPASS_RETRY = 2;
const OVERPASS_DELAY_MS = 300;
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

/* ===================== WebMercator / Tile ===================== */
const R = 6378137;
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }
function lonToMercX(lon){ return R * deg2rad(lon); }
function latToMercY(lat){ return R * Math.log(Math.tan(Math.PI/4 + deg2rad(lat)/2)); }
function mercXToLon(x){ return rad2deg(x / R); }
function mercYToLat(y){ return rad2deg(2 * Math.atan(Math.exp(y / R)) - Math.PI/2); }
function lonLatToMerc(lon, lat){ return { x: lonToMercX(lon), y: latToMercY(lat) }; }
function tile2lon(x,z){ return x / Math.pow(2,z) * 360 - 180; }
function tile2lat(y,z){ const n = Math.PI - 2 * Math.PI * y / Math.pow(2,z); return Math.atan(Math.sinh(n)) * 180 / Math.PI; }
function lonToTileX(lon, zoom){ return Math.floor((lon+180)/360*Math.pow(2,zoom)); }
function latToTileY(lat, zoom){ const a = Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180)); return Math.floor((1 - a/Math.PI)/2*Math.pow(2,zoom)); }

/* ===================== ORIGIN ===================== */
const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT);

/* ===================== Three.js ÂàùÊúüÂåñ ===================== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 20, 40);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.target.set(0,0,0);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(500,1000,500);
scene.add(dir);

/* ===================== „Ç≠„É£„ÉÉ„Ç∑„É• ===================== */
const loadedTiles = new Map();
const fetchQueue = [];
let activeFetches = 0;
const geoCache = new Map();
const imgCache = new Map();
const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");

/* ===================== Tile bbox ===================== */
function tileBBoxLonLat(x,y,z){
    return { west: tile2lon(x,z), north: tile2lat(y,z), east: tile2lon(x+1,z), south: tile2lat(y+1,z) };
}
function bboxToOverpassQuery(bbox){
    return `[out:json][timeout:25];(way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east}););(._;>;);out geom;`;
}

/* ===================== Fetch Queue ===================== */
async function fetchOverpassForTile(x,y,z, tries=0){
    const key = `${x}_${y}`;
    if(geoCache.has(key)) return geoCache.get(key);
    const bbox = tileBBoxLonLat(x,y,z);
    const query = bboxToOverpassQuery(bbox);

    try {
        activeFetches++;
        const res = await fetch(OVERPASS_URL, {method:"POST", body:query});
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        const data = { bbox, json };
        geoCache.set(key, data);
        return data;
    } catch(err){
        if(tries < OVERPASS_RETRY){
            await new Promise(r=>setTimeout(r,500*Math.pow(2,tries)));
            return fetchOverpassForTile(x,y,z,tries+1);
        } else return null;
    } finally { activeFetches--; }
}

function enqueueFetch(fn){ return new Promise(resolve=>{ fetchQueue.push({fn,resolve}); processQueue(); }); }
function processQueue(){
    if(activeFetches>=MAX_CONCURRENT_FETCH) return;
    const job = fetchQueue.shift(); if(!job) return;
    job.fn().then(r=>job.resolve(r)).finally(()=>setTimeout(processQueue, OVERPASS_DELAY_MS));
}

/* ===================== Â∫ä„Çø„Ç§„É´ ===================== */
function addFloorMeshToGroup(tex, bbox, group){
    const westMx = lonToMercX(bbox.west);
    const eastMx = lonToMercX(bbox.east);
    const northMy = latToMercY(bbox.north);
    const southMy = latToMercY(bbox.south);
    const mercW = eastMx - westMx;
    const mercH = northMy - southMy;
    const centerX = (westMx + eastMx)/2 - ORIGIN_M.x;
    const centerZ = -((southMy + northMy)/2 - ORIGIN_M.y);

    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(mercW, mercH),
        new THREE.MeshPhongMaterial({ map: tex, side: THREE.DoubleSide })
    );
    plane.rotation.x = -Math.PI/2;
    plane.position.set(centerX, 0, centerZ);

    group.add(plane);
}

/* ===================== Âª∫Áâ© ===================== */
function mercToWorld(mx, my){
    return { x: mx - ORIGIN_M.x, z: -(my - ORIGIN_M.y) };
}

function createExtrudeMeshFromWay(el){
    if(!el || !el.geometry || !Array.isArray(el.geometry) || el.geometry.length < 3) return null;
    let minX = Infinity, minZ = Infinity, maxX = -Infinity, maxZ = -Infinity;
    const worldPts = [];
    for(const pt of el.geometry){
        const m = lonLatToMerc(pt.lon, pt.lat);
        const w = mercToWorld(m.x, m.y);
        worldPts.push(w);
        if(w.x < minX) minX = w.x; if(w.x > maxX) maxX = w.x;
        if(w.z < minZ) minZ = w.z; if(w.z > maxZ) maxZ = w.z;
    }
    const cx = (minX + maxX)/2;
    const cz = (minZ + maxZ)/2;
    const shape = new THREE.Shape();
    for(let i=0;i<worldPts.length;i++){
        const p = worldPts[i];
        const lx = p.x - cx;
        const lz = p.z - cz;
        if(i===0) shape.moveTo(lx,lz); else shape.lineTo(lx,lz);
    }
    const tags = el.tags || {};
    let height = 10;
    if(tags.height) height = parseFloat(String(tags.height).replace('m',''))||height;
    else if(tags["building:levels"]) height = (parseFloat(tags["building:levels"])||1)*3;
    const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false, curveSegments: 1 });
    geo.rotateX(-Math.PI/2);
    geo.computeBoundingBox();
    const minY = geo.boundingBox.min.y;
    const maxY = geo.boundingBox.max.y;
    geo.translate(0,-(minY+maxY)/2,0);
    const mat = new THREE.MeshPhongMaterial({ map: windowTex, color:0xdddddd });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(cx,height/2,cz);
    return mesh;
}

function createBoxLODFromWay(el,height){
    let minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;
    for(const pt of el.geometry){
        const m = lonLatToMerc(pt.lon, pt.lat);
        const w = mercToWorld(m.x, m.y);
        if(w.x<minX) minX=w.x; if(w.x>maxX) maxX=w.x;
        if(w.z<minZ) minZ=w.z; if(w.z>maxZ) maxZ=w.z;
    }
    const sx = Math.max(1,maxX-minX);
    const sz = Math.max(1,maxZ-minZ);
    const cx = (minX+maxX)/2;
    const cz = (minZ+maxZ)/2;
    const geo = new THREE.BoxGeometry(sx,height,sz);
    const mat = new THREE.MeshPhongMaterial({color:0x999999});
    const box = new THREE.Mesh(geo, mat);
    box.position.set(cx, height/2, cz);
    return box;
}

function createBuildingLOD(el){
    const tags = el.tags||{};
    if(!tags.building) return null;
    let height = 10;
    if(tags.height) height = parseFloat(String(tags.height).replace('m',''))||height;
    else if(tags["building:levels"]) height = (parseFloat(tags["building:levels"])||1)*3;
    const lod = new THREE.LOD();
    try{
        const extrude = createExtrudeMeshFromWay(el);
        if(extrude) lod.addLevel(extrude,0);
    } catch(e){ console.warn("detail fail",e); }
    const box1 = createBoxLODFromWay(el,Math.max(3,height*0.9));
    const box2 = createBoxLODFromWay(el,Math.max(3,height*0.7));
    if(box1) lod.addLevel(box1,1000);
    if(box2) lod.addLevel(box2,1500);
    return lod;
}

/* ===================== „Çø„Ç§„É´ËøΩÂä† ===================== */
function addTileToScene(x,y,z,data){
    const key = `${x}_${y}`;
    if(loadedTiles.has(key)) return;
    const group = new THREE.Group();
    group.userData={x,y,z,bbox:data.bbox};

    const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
    if(imgCache.has(tileUrl)){
        addFloorMeshToGroup(imgCache.get(tileUrl), data.bbox, group);
    } else {
        new THREE.TextureLoader().load(tileUrl, tex=>{
            tex.flipY = true;
            imgCache.set(tileUrl, tex);
            addFloorMeshToGroup(tex, data.bbox, group);
        });
    }

    const els = data.json.elements||[];
    for(const el of els){
        if(el.type!=="way"||!el.geometry) continue;
        try{
            const b = createBuildingLOD(el);
            if(b) group.add(b);
        } catch(e){ console.warn("building create err",e); }
    }

    scene.add(group);
    loadedTiles.set(key,{group,lastUsed:Date.now(),bbox:data.bbox});
}

/* ===================== „Çø„Ç§„É´ÁÆ°ÁêÜ ===================== */
function unloadFarTiles(cx,cy){
    for(const [key,info] of Array.from(loadedTiles)){
        const [tx,ty] = key.split("_").map(n=>parseInt(n,10));
        if(Math.abs(tx-cx)>LOAD_RADIUS+1 || Math.abs(ty-cy)>LOAD_RADIUS+1){
            const grp = info.group;
            scene.remove(grp);
            grp.traverse(obj=>{
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) Array.isArray(obj.material)?obj.material.forEach(m=>m.dispose()):obj.material.dispose();
            });
            loadedTiles.delete(key);
        }
    }
}

/* ===================== „Ç´„É°„É©‰∏≠ÂøÉ ===================== */
function cameraToLonLat(){
    const tx = controls.target.x;
    const tz = controls.target.z;
    const m = { x: tx + ORIGIN_M.x, y: -(tz) + ORIGIN_M.y };
    return { lon: mercXToLon(m.x), lat: mercYToLat(m.y) };
}

/* ===================== Tile Êõ¥Êñ∞„É´„Éº„Éó ===================== */
let lastUpdate=0;
const MIN_UPDATE_INTERVAL=1200;
async function updateTilesAroundCamera(){
    const now = performance.now();
    if(now - lastUpdate < MIN_UPDATE_INTERVAL) return;
    lastUpdate = now;
    const center = cameraToLonLat();
    const cx = lonToTileX(center.lon, ZOOM);
    const cy = latToTileY(center.lat, ZOOM);

    for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
        for(let dy=-LOAD_RADIUS; dy<=LOAD_RADIUS; dy++){
            const tx=cx+dx, ty=cy+dy;
            const key=`${tx}_${ty}`;
            if(loadedTiles.has(key)){ loadedTiles.get(key).lastUsed=Date.now(); continue; }
            enqueueFetch(async()=>{
                const res = await fetchOverpassForTile(tx, ty, ZOOM);
                if(res) addTileToScene(tx, ty, ZOOM, res);
                return res;
            });
        }
    }
}

/* ===================== Èõ≤„Çπ„ÉÜ„Éº„Ç∏ÔºàË∂≥Â†¥Ôºâ ===================== */
function createSkyPlatform(){
    const geo = new THREE.CircleGeometry(200,48);
    const mat = new THREE.MeshStandardMaterial({ color:0xffffff, opacity:0.6, transparent:true, roughness:0.9, metalness:0 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.position.set(0,500,0);
    scene.add(mesh);
    return mesh;
}

/* ===================== „Ç≠„É£„É©„ÇØ„Çø„Éº ===================== */
const character = new THREE.Mesh(
    new THREE.CapsuleGeometry(1,2,4,8),
    new THREE.MeshStandardMaterial({color:0xff0000})
);
scene.add(character);
const skyPlatform = createSkyPlatform();
character.position.set(skyPlatform.position.x, skyPlatform.position.y+2, skyPlatform.position.z);

/* ===================== TPS „Ç´„É°„É©Âà∂Âæ° ===================== */
const camOffset = new THREE.Vector3(0,6,10);
function updateCamera(){
    const targetPos = character.position.clone();
    const camPos = targetPos.clone().add(camOffset);
    camera.position.lerp(camPos, 0.1);
    camera.lookAt(targetPos);
}

/* ===================== ÁßªÂãïÂà∂Âæ° ===================== */
const move = { f:0, b:0, l:0, r:0, jump:0 };
const speed = 0.5;
let velocityY = 0;
const gravity = -0.02;

window.addEventListener('keydown', e=>{
    if(e.key==='w') move.f=1;
    if(e.key==='s') move.b=1;
    if(e.key==='a') move.l=1;
    if(e.key==='d') move.r=1;
});
window.addEventListener('keyup', e=>{
    if(e.key==='w') move.f=0;
    if(e.key==='s') move.b=0;
    if(e.key==='a') move.l=0;
    if(e.key==='d') move.r=0;
});
document.getElementById('jumpBtn').addEventListener('click', ()=>{ 
    if(character.position.y<=skyPlatform.position.y+2.1) velocityY=0.5; 
});

/* ===================== Animation ===================== */
function animate(){
    requestAnimationFrame(animate);
    controls.update();

    // „Ç≠„É£„É©ÁßªÂãï
    const dir = new THREE.Vector3();
    if(move.f) dir.z -= 1;
    if(move.b) dir.z += 1;
    if(move.l) dir.x -= 1;
    if(move.r) dir.x += 1;
    dir.normalize();
    dir.applyAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y);
    character.position.addScaledVector(dir,speed);

    // ÈáçÂäõ / „Ç∏„É£„É≥„Éó
    velocityY += gravity;
    character.position.y += velocityY;
    if(character.position.y < skyPlatform.position.y+2){ character.position.y = skyPlatform.position.y+2; velocityY = 0; }

    // TPS „Ç´„É°„É©
    updateCamera();

    // „Çø„Ç§„É´Ë™≠„ÅøËæº„Åø
    updateTilesAroundCamera();

    renderer.render(scene,camera);
}
animate();

/* ===================== Resize ===================== */
window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
});

/* keyboard radius */
window.addEventListener('keydown', e=>{
    if(e.key==="+"){ LOAD_RADIUS=Math.min(4,LOAD_RADIUS+1); }
    if(e.key==="-"){ LOAD_RADIUS=Math.max(0,LOAD_RADIUS-1); }
});

processQueue();
console.log("TPS OSM Viewer started.");
</script>
</body>
</html>
