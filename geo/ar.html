<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>AR 古地図（全国対応） + 行政界 — Three.js r128</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif}
  canvas{display:block;width:100%;height:100%}
  /* UI overlay (dom-overlay) — AR中でも押せる */
  #ui {
    position: fixed;
    left: 10px;
    top: 10px;
    z-index: 10000;
    background: rgba(0,0,0,0.45);
    color: #fff;
    padding: 10px;
    border-radius: 10px;
    max-width: 92%;
    box-shadow: 0 6px 18px rgba(0,0,0,0.4);
  }
  #ui input, #ui select { font-size:13px; padding:6px; border-radius:6px; margin-top:6px; width:100%;}
  #ui button { margin-top:8px; padding:8px 10px; border-radius:8px; border:none; background:#1976d2; color:white; cursor:pointer; font-weight:600;}
  #status {
    position: fixed;
    left: 10px;
    bottom: 10px;
    z-index:10000;
    background: rgba(0,0,0,0.45);
    color: #fff;
    padding:8px;
    border-radius:8px;
    font-size:13px;
  }
</style>
</head>
<body>
  <div id="ui">
    <div style="font-weight:700;margin-bottom:6px">AR 古地図 + 行政界（全国対応）</div>

    <button id="start-ar">AR を開始</button>

    <label style="display:block;margin-top:8px">
      タイルテンプレート（全国対応の例：農研機構）：
      <input id="tile-template" value="https://aginfo.cgk.affrc.go.jp/ws/tmc/1.0.0/200k/map/{z}/{x}/{y}.png">
    </label>

    <label style="display:block;margin-top:6px">
      タイルズーム（例:14〜16 推奨）
      <input id="tile-zoom" value="14">
    </label>

    <label style="display:block;margin-top:6px">
      ステッチ範囲（奇数）: 
      <select id="tile-grid">
        <option>1</option>
        <option selected>3</option>
        <option>5</option>
      </select>
    </label>

    <label style="display:block;margin-top:6px">
      行政界 GeoJSON URL（CORS の都合で取得できない場合はローカルに保存してください）
      <input id="geojson-url" value="https://raw.githubusercontent.com/geolonia/japanese-admin-boundaries/master/dist/japan.geojson">
    </label>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="load-geo">行政界を取得</button>
      <button id="clear-scene">配置をクリア</button>
    </div>

    <div style="font-size:12px;margin-top:8px;color:#ddd">
      説明：① ARを開始 → ② カメラで床を検出（reticle 表示）→ ③ 画面タップで古地図（中心：端末の現在地）と行政界を配置します。
    </div>
  </div>

  <div id="status">状態: 待機</div>

<script>
/* ----------------------
  概要
  - 現在地を中心にタイルを取得し、メートルスケールで平面に貼る
  - GeoJSON（行政界）を同一中心へ相対配置（メートル単位）
  - AR中は dom-overlay を使ってUIを前面に表示
  注意：CORS の影響でタイル・GeoJSON を外部から取得できない場合は、
  それらをこのHTMLと同じホストに置いて相対URLを指定してください。
------------------------*/

let scene, camera, renderer;
let reticle;
let hitTestSource = null;
let hitTestSourceRequested = false;
let xrRefSpace = null;
let placedObjects = [];
let adminGeoJSON = null;

initThree();

function initThree(){
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  // reticle for placement
  const ring = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color:0x00ffff, side:THREE.DoubleSide });
  reticle = new THREE.Mesh(ring, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  window.addEventListener('resize', onWindowResize);
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ----------------------
  UI & イベント
------------------------*/
const startBtn = document.getElementById('start-ar');
const statusEl = document.getElementById('status');
const loadGeoBtn = document.getElementById('load-geo');
const clearBtn = document.getElementById('clear-scene');

startBtn.addEventListener('click', startAR);
loadGeoBtn.addEventListener('click', loadAdminGeoJSON);
clearBtn.addEventListener('click', clearPlacedObjects);

async function startAR(){
  if (!('xr' in navigator)) {
    alert('このブラウザは WebXR をサポートしていません');
    return;
  }

  try {
    const supported = await navigator.xr.isSessionSupported('immersive-ar');
    if (!supported) {
      alert('端末／ブラウザが AR をサポートしていません');
      return;
    }
  } catch(e){
    console.warn(e);
  }

  try {
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test', 'dom-overlay'],
      domOverlay: { root: document.body }
    });
    onSessionStarted(session);
  } catch(err) {
    alert('AR セッションの開始に失敗: ' + err.message);
  }
}

async function onSessionStarted(session){
  renderer.xr.setSession(session);
  xrRefSpace = await session.requestReferenceSpace('local-floor').catch(()=> session.requestReferenceSpace('local'));
  hitTestSourceRequested = false;
  placedObjects = [];

  session.addEventListener('select', (ev) => {
    onSelect(ev, session);
  });

  session.addEventListener('end', () => {
    hitTestSourceRequested = false;
    hitTestSource = null;
    renderer.setAnimationLoop(null);
    reticle.visible = false;
    statusEl.textContent = '状態: セッション終了';
  });

  renderer.setAnimationLoop((time, frame) => {
    if (frame) {
      const sess = frame.session;

      if (!hitTestSourceRequested) {
        sess.requestReferenceSpace('viewer').then((viewerSpace) => {
          sess.requestHitTestSource({ space: viewerSpace }).then((source) => {
            hitTestSource = source;
          }).catch(e => console.warn('hit test source failed', e));
        }).catch(e => console.warn('viewer refspace failed', e));
        hitTestSourceRequested = true;
      }

      if (hitTestSource) {
        const hitResults = frame.getHitTestResults(hitTestSource);
        if (hitResults.length > 0) {
          const hit = hitResults[0];
          const pose = hit.getPose(xrRefSpace);
          if (pose) {
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        } else {
          reticle.visible = false;
        }
      }
    }

    renderer.render(scene, camera);
  });

  statusEl.textContent = '状態: AR セッション中 — カメラで平面（床）を検出してからタップ';
}

/* ----------------------
  GeoJSON（行政界）を読み込む
------------------------*/
async function loadAdminGeoJSON(){
  const url = document.getElementById('geojson-url').value.trim();
  statusEl.textContent = '状態: GeoJSON 取得中…';
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const j = await res.json();
    adminGeoJSON = j;
    const count = (j.features && j.features.length) || 0;
    statusEl.textContent = `状態: GeoJSON 読込完了 (${count} features)`;
  } catch (e) {
    console.error(e);
    adminGeoJSON = null;
    statusEl.textContent = '状態: GeoJSON 取得失敗。CORS 制限の可能性あり。ローカルホスティングを検討してください。';
    alert('GeoJSON の取得に失敗しました。\nURL と CORS を確認するか、GeoJSON ファイルをこのHTMLと同じサーバに置いてください。\n' + e.message);
  }
}

/* ----------------------
  select (タップ) 処理：現在地を中心にタイルを取得して配置
------------------------*/

async function onSelect(ev, session){
  if (!reticle.visible) {
    // nothing to place
    return;
  }

  // try to obtain geolocation for center; if unavailable use fallback (Tokyo)
  let centerLat, centerLon;
  try {
    const pos = await getCurrentPosition({enableHighAccuracy:true, timeout:7000});
    centerLat = pos.coords.latitude;
    centerLon = pos.coords.longitude;
  } catch(e) {
    console.warn('geolocation failed; using Tokyo fallback', e);
    centerLat = 35.681236; centerLon = 139.767125;
    alert('位置情報の取得に失敗しました。端末の位置情報を許可するか、以後はデフォルト（東京駅）で表示します。');
  }

  // UI values
  const template = document.getElementById('tile-template').value.trim();
  const zoom = parseInt(document.getElementById('tile-zoom').value) || 14;
  const grid = parseInt(document.getElementById('tile-grid').value) || 3;

  // compute tile x,y center
  const tile = lonLatToTile(centerLon, centerLat, zoom);

  // stitch tiles into a texture (grid x grid)
  statusEl.textContent = '状態: タイル取得中…（CORS によりブロックされる場合あり）';
  let tex;
  try {
    tex = await createStitchedTileTexture(template, zoom, tile.x, tile.y, grid);
  } catch(e){
    console.error('tile stitch failed', e);
    statusEl.textContent = '状態: タイル取得に失敗（CORS か URL を確認）';
    alert('古地図タイルの取得に失敗しました。CORS が原因のことが多いです。タイルを同一ホストに置くか、別のテンプレートを試してください。');
    return;
  }

  // compute tile size in meters at this lat
  const metersPerTile = tileSizeMeters(centerLat, zoom);
  const mapSizeMeters = metersPerTile * grid;

  // create plane geometry in meters
  const geometry = new THREE.PlaneGeometry(mapSizeMeters, mapSizeMeters);
  const material = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide });
  const plane = new THREE.Mesh(geometry, material);
  plane.rotation.x = -Math.PI/2;

  // place plane at reticle pose (we'll set matrix from reticle)
  plane.matrixAutoUpdate = false;
  plane.matrix.copy(reticle.matrix);

  // ensure plane is centered at the reticle: reticle is location, but plane geometry center overlaps; OK.
  scene.add(plane);
  placedObjects.push(plane);

  // now draw admin features if loaded
  if (adminGeoJSON) {
    statusEl.textContent = '状態: 行政界を描画中…';
    // create group anchored at same pose as plane
    const group = new THREE.Group();
    group.matrixAutoUpdate = false;
    group.matrix.copy(reticle.matrix);

    // For each feature, convert lon/lat to meter positions relative to centerLon/centerLat and add lines/fill
    const features = adminGeoJSON.features || [];
    for (const f of features) {
      const geom = f.geometry;
      if (!geom) continue;
      if (geom.type === 'Polygon') {
        const mesh = geoPolygonToMesh(geom.coordinates, centerLon, centerLat);
        if (mesh) group.add(mesh);
      } else if (geom.type === 'MultiPolygon') {
        for (const poly of geom.coordinates) {
          const mesh = geoPolygonToMesh(poly, centerLon, centerLat);
          if (mesh) group.add(mesh);
        }
      } else if (geom.type === 'LineString') {
        const ln = geoLineToMesh(geom.coordinates, centerLon, centerLat);
        if (ln) group.add(ln);
      } else if (geom.type === 'MultiLineString') {
        for (const lncoords of geom.coordinates) {
          const ln = geoLineToMesh(lncoords, centerLon, centerLat);
          if (ln) group.add(ln);
        }
      }
    }

    scene.add(group);
    placedObjects.push(group);
    statusEl.textContent = '状態: 配置完了（古地図＋行政界）';
  } else {
    statusEl.textContent = '状態: 古地図配置完了（行政界は未ロード）';
  }
}

/* ----------------------
  Geo -> three.js helpers:
  lon/lat -> meters relative to center
------------------------*/
function metersPerDegLat(){ return 111320.0; }
function metersPerDegLon(lat){ return Math.cos(lat * Math.PI / 180.0) * 111320.0; }

function lonLatToPosition(lon, lat, centerLon, centerLat){
  const dx = (lon - centerLon) * metersPerDegLon(centerLat);
  const dz = (lat - centerLat) * metersPerDegLat();
  // X east, Z negative north (so north -> -z)
  return new THREE.Vector3(dx, 0, -dz);
}

function geoLineToMesh(coordinates, centerLon, centerLat){
  const pts = [];
  for (const c of coordinates) {
    const p = lonLatToPosition(c[0], c[1], centerLon, centerLat);
    pts.push(new THREE.Vector3(p.x, 0.02, p.z));
  }
  if (pts.length < 2) return null;
  const geom = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color: 0xff4444 });
  return new THREE.Line(geom, mat);
}

function geoPolygonToMesh(polygonCoords, centerLon, centerLat){
  // polygonCoords: [ [ [lon,lat], ... ], [inner ring], ... ]
  const outer = polygonCoords[0];
  const pts3 = outer.map(c => {
    const p = lonLatToPosition(c[0], c[1], centerLon, centerLat);
    return new THREE.Vector3(p.x, 0.015, p.z);
  });
  if (pts3.length < 3) return null;

  // outline
  const outlineGeom = new THREE.BufferGeometry().setFromPoints(pts3);
  const outline = new THREE.LineLoop(outlineGeom, new THREE.LineBasicMaterial({ color:0x00ff00 }));

  // fill via simple triangulation using Shape
  const pts2 = outer.map(c => {
    const p = lonLatToPosition(c[0], c[1], centerLon, centerLat);
    return new THREE.Vector2(p.x, p.z);
  });
  const shape = new THREE.Shape(pts2);
  const shapeGeom = new THREE.ShapeBufferGeometry(shape);
  const fill = new THREE.Mesh(shapeGeom, new THREE.MeshStandardMaterial({ color:0x00ff00, opacity:0.18, transparent:true, side:THREE.DoubleSide}));
  fill.rotation.x = -Math.PI/2;
  fill.position.y = 0.01;

  const g = new THREE.Group();
  g.add(outline);
  g.add(fill);
  return g;
}

/* ----------------------
  Tile helpers: lon/lat <-> tile coords, tile meters, stitch canvas
------------------------*/
function lonLatToTile(lon, lat, zoom){
  const latRad = lat * Math.PI / 180.0;
  const n = Math.pow(2, zoom);
  const x = Math.floor((lon + 180.0) / 360.0 * n);
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y, z: zoom };
}

function tileXYToLonLat(x, y, z){
  const n = Math.pow(2, z);
  const lon = x / n * 360 - 180;
  const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
  const lat = latRad * 180 / Math.PI;
  return { lon, lat };
}

function tileSizeMeters(lat, zoom){
  // meters per tile at latitude
  const R = 6378137.0;
  const metersPerPixel = (Math.cos(lat * Math.PI / 180.0) * 2 * Math.PI * R) / (Math.pow(2, zoom) * 256.0);
  return metersPerPixel * 256.0;
}

async function createStitchedTileTexture(template, z, cx, cy, gridSize){
  // gridSize odd (1,3,5). Create canvas and fetch tiles into it.
  const tilePx = 256;
  const sizePx = gridSize * tilePx;
  const canvas = document.createElement('canvas');
  canvas.width = sizePx;
  canvas.height = sizePx;
  const ctx = canvas.getContext('2d');

  const half = Math.floor(gridSize / 2);
  const promises = [];
  for (let dy = -half; dy <= half; dy++){
    for (let dx = -half; dx <= half; dx++){
      const tx = cx + dx;
      const ty = cy + dy;
      const url = template.replace('{z}', z).replace('{x}', tx).replace('{y}', ty);
      promises.push(drawTile(url, ctx, (dx+half)*tilePx, (dy+half)*tilePx));
    }
  }

  // Wait for all; if some fail due to CORS, reject so caller can show message
  await Promise.all(promises);
  const tex = new THREE.CanvasTexture(canvas);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  return tex;
}

function drawTile(url, ctx, dx, dy){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      try {
        ctx.drawImage(img, dx, dy);
        resolve();
      } catch(e){
        reject(e);
      }
    };
    img.onerror = (e) => {
      reject(new Error('タイルロード失敗: ' + url));
    };
    img.src = url;
  });
}

/* ----------------------
  util: getCurrentPosition (Promise)
------------------------*/
function getCurrentPosition(options){
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation unsupported'));
      return;
    }
    navigator.geolocation.getCurrentPosition(resolve, reject, options);
  });
}

/* ----------------------
  その他ユーティリティ
------------------------*/
function clearPlacedObjects(){
  for (const o of placedObjects) {
    scene.remove(o);
  }
  placedObjects = [];
  statusEl.textContent = '状態: 配置をクリアしました';
}

window.clearPlacedObjects = clearPlacedObjects;

/* Expose a debug reference */
window._ar_debug = { scene, renderer };

/* EOF */
</script>
</body>
</html>
