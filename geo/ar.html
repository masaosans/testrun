<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>AR 古地図 + 行政界 — 修正版（カメラ映像対応）</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<!-- three.js r0.128 -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<!-- eruda for debugging (optional) -->
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>

<style>
  html,body{height:100%;margin:0;padding:0;overflow:hidden;background:#000}
  /* canvas: keep behind UI and fill screen */
  canvas { position: fixed; left:0; top:0; width:100%; height:100%; z-index:1; display:block; }
  /* UI: DOM overlay root (do not cover full screen) */
  #ui {
    position: fixed;
    left: 10px;
    top: 10px;
    z-index: 10010;
    width: 320px;
    background: rgba(0,0,0,0.65);
    color: #fff;
    padding: 12px;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.6);
    pointer-events: auto;
  }
  #ui label { display:block; font-size:13px; margin-top:8px; }
  #ui input, #ui select, #ui button { width:100%; margin-top:6px; padding:8px; border-radius:8px; border: none; box-sizing:border-box; }
  #status {
    position: fixed; left: 10px; bottom: 10px; z-index:10010;
    background: rgba(0,0,0,0.65); color:#fff; padding:8px 10px; border-radius:8px; font-size:13px;
  }
  small.note { display:block; color:#ddd; margin-top:8px; font-size:12px; }
</style>
</head>
<body>
  <!-- UI used as DOM overlay root (important: not body) -->
  <div id="ui">
    <div style="font-weight:700">AR 古地図 + 行政界（修正版）</div>

    <button id="startAR">AR を開始</button>

    <label>古地図タイルテンプレート（例：農研・全国）
      <input id="tileTemplate" value="https://aginfo.cgk.affrc.go.jp/ws/tmc/1.0.0/200k/map/{z}/{x}/{y}.png">
    </label>

    <label>タイルズーム
      <input id="tileZoom" value="14">
    </label>

    <label>ステッチ (1 / 3 / 5)
      <select id="tileGrid"><option>1</option><option selected>3</option><option>5</option></select>
    </label>

    <label>行政界 GeoJSON URL
      <input id="geoUrl" value="https://raw.githubusercontent.com/geolonia/japanese-admin-boundaries/master/dist/japan.geojson">
    </label>

    <button id="loadGeo">行政界をロード</button>
    <button id="clearPlaced">配置クリア</button>

    <small class="note">注意：必ず HTTPS。CORSで失敗する場合はファイルを同一ホストに置いてください。</small>
  </div>

  <div id="status">状態: 待機</div>

<script>
/* ===========================
   修正版：カメラ映像黒画面対策
   - renderer: alpha:true に変更
   - 背景色を透明に設定
   - セッション設定順序を修正
   =========================== */

let scene, camera, renderer;
let reticle, lastReticleMatrix = null;
let xrRefSpace = null;
let hitTestSource = null;
let hitTestSourceRequested = false;
let placedObjects = [];
let adminGeoJSON = null;
const statusEl = document.getElementById('status');

initThree();

function initThree() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);

  // 修正: alpha:true に変更して透明背景を許可
  renderer = new THREE.WebGLRenderer({ 
    antialias: true, 
    alpha: true,  // ← 透明背景を許可
    preserveDrawingBuffer: false,
    powerPreference: 'high-performance'  // ← パフォーマンス優先
  });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  
  // 背景色を透明に設定
  renderer.setClearColor(0x000000, 0);

  // Append canvas (Three will create it)
  document.body.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  // Reticle
  const ring = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide });
  reticle = new THREE.Mesh(ring, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ---------------- UI events ---------------- */
document.getElementById('startAR').addEventListener('click', startAR);
document.getElementById('loadGeo').addEventListener('click', loadAdminGeoJSON);
document.getElementById('clearPlaced').addEventListener('click', clearPlacedObjects);

/* ---------------- AR start ---------------- */
async function startAR(){
  if (!navigator.xr) {
    alert('WebXR が見つかりません。対応ブラウザで実行してください。');
    return;
  }

  const supported = await navigator.xr.isSessionSupported('immersive-ar').catch(() => false);
  if (!supported) {
    alert('このデバイス／ブラウザは immersive-ar をサポートしていません。');
    return;
  }

  statusEl.textContent = '状態: セッション作成中…';

  try {
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test', 'dom-overlay'],
      domOverlay: { root: document.getElementById('ui') }
    });

    // 修正: Three.jsのセッションを先に設定
    renderer.xr.setSession(session);

    // Ensure GL is XR-compatible
    const gl = renderer.getContext();
    if (gl.makeXRCompatible) {
      await gl.makeXRCompatible();
    }

    // 修正: XRWebGLLayerの設定（Three.jsセッション設定後）
    try {
      const baseLayer = new XRWebGLLayer(session, gl);
      await session.updateRenderState({ 
        baseLayer: baseLayer,
        depthData: session.renderState.supportedDepthDataFormats ? 
          session.renderState.supportedDepthDataFormats[0] : undefined
      });
    } catch(e) {
      console.warn('XRWebGLLayer construction/update failed (may be fine):', e);
      // continue — Three.js may handle it
    }

    // Use 'local' refspace for stability
    xrRefSpace = await session.requestReferenceSpace('local');

    // reset hitTest flags
    hitTestSourceRequested = false;

    // event listeners
    session.addEventListener('select', onSelect);
    session.addEventListener('end', () => {
      hitTestSourceRequested = false;
      hitTestSource = null;
      renderer.setAnimationLoop(null);
      reticle.visible = false;
      statusEl.textContent = '状態: セッション終了';
    });

    // start render loop
    renderer.setAnimationLoop(render);

    statusEl.textContent = '状態: AR 実行中 — 床を検出してから画面をタップ';
  } catch(err) {
    console.error('startAR error', err);
    alert('AR セッション開始に失敗しました: ' + (err && err.message ? err.message : err));
    statusEl.textContent = '状態: AR セッション開始失敗';
  }
}

/* ---------------- render loop ---------------- */
function render(timestamp, frame){
  // 修正: frameがない場合は早期リターン
  if (!frame) {
    return;
  }

  const session = frame.session;
  
  // request hit test source once
  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then(viewerSpace => {
      session.requestHitTestSource({ space: viewerSpace }).then(source => {
        hitTestSource = source;
      }).catch(e => {
        console.warn('requestHitTestSource failed', e);
      });
    }).catch(e => console.warn('requestReferenceSpace(viewer) failed', e));
    hitTestSourceRequested = true;
  }

  // update reticle if hits
  if (hitTestSource) {
    const hitResults = frame.getHitTestResults(hitTestSource);
    if (hitResults.length > 0) {
      const pose = hitResults[0].getPose(xrRefSpace);
      if (pose) {
        const m = new THREE.Matrix4().fromArray(pose.transform.matrix);
        reticle.matrix.copy(m);
        reticle.visible = true;
        lastReticleMatrix = m.clone();
      } else {
        reticle.visible = false;
        lastReticleMatrix = null;
      }
    } else {
      reticle.visible = false;
      lastReticleMatrix = null;
    }
  }

  // render
  renderer.render(scene, camera);
}

/* ---------------- onSelect: place map + geojson ---------------- */
async function onSelect(){
  if (!lastReticleMatrix) {
    statusEl.textContent = '状態: 平面が見つかりません';
    return;
  }

  // get current position (fallback to Tokyo)
  let centerLat = 35.681236, centerLon = 139.767125;
  try {
    const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy:true, timeout:7000 }));
    centerLat = pos.coords.latitude; centerLon = pos.coords.longitude;
  } catch(e){
    console.warn('geolocation failed, fallback to Tokyo', e);
  }

  statusEl.textContent = '状態: タイル取得中…';

  const tmpl = document.getElementById('tileTemplate').value.trim();
  const zoom = parseInt(document.getElementById('tileZoom').value || '14');
  const grid = parseInt(document.getElementById('tileGrid').value || '3');

  const tile = lonLatToTile(centerLon, centerLat, zoom);

  let tex;
  try {
    tex = await createStitchedTileTexture(tmpl, zoom, tile.x, tile.y, grid);
  } catch(e) {
    console.error('tile fetch failed', e);
    alert('古地図タイル取得失敗: ' + e.message);
    statusEl.textContent = '状態: タイル取得失敗';
    return;
  }

  const meters = tileSizeMeters(centerLat, zoom) * grid;
  const geom = new THREE.PlaneGeometry(meters, meters);
  const mat = new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide });
  const plane = new THREE.Mesh(geom, mat);
  plane.rotation.x = -Math.PI/2;
  plane.matrixAutoUpdate = false;
  plane.matrix.copy(lastReticleMatrix);
  scene.add(plane);
  placedObjects.push(plane);

  // draw geojson if loaded
  if (adminGeoJSON) {
    drawGeoJSON(centerLon, centerLat, lastReticleMatrix);
  }

  statusEl.textContent = `状態: 配置完了（${centerLat.toFixed(6)}, ${centerLon.toFixed(6)})`;
}

/* ---------------- load admin geojson ---------------- */
async function loadAdminGeoJSON(){
  const url = document.getElementById('geoUrl').value.trim();
  statusEl.textContent = '状態: GeoJSON 取得中…';
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    adminGeoJSON = await res.json();
    statusEl.textContent = '状態: GeoJSON 読込完了';
  } catch(e) {
    console.error('loadAdminGeoJSON failed', e);
    alert('GeoJSON 取得失敗: ' + (e && e.message ? e.message : e));
    statusEl.textContent = '状態: GeoJSON 取得失敗';
  }
}

/* ---------------- draw geojson ---------------- */
function drawGeoJSON(centerLon, centerLat, baseMatrix){
  const group = new THREE.Group();
  group.matrixAutoUpdate = false;
  group.matrix.copy(baseMatrix);

  const features = adminGeoJSON.features || [];
  for (const f of features) {
    const g = f.geometry;
    if (!g) continue;
    if (g.type === 'Polygon') {
      const o = polygonToLine(g.coordinates[0], centerLon, centerLat);
      if (o) group.add(o);
    } else if (g.type === 'MultiPolygon') {
      for (const poly of g.coordinates) {
        const o = polygonToLine(poly[0], centerLon, centerLat);
        if (o) group.add(o);
      }
    } else if (g.type === 'LineString') {
      const o = polygonToLine(g.coordinates, centerLon, centerLat);
      if (o) group.add(o);
    }
  }

  scene.add(group);
  placedObjects.push(group);
}

function polygonToLine(coords, centerLon, centerLat) {
  if (!coords || coords.length < 2) return null;
  const pts = [];
  for (const c of coords) {
    const p = lonLatToPosition(c[0], c[1], centerLon, centerLat);
    pts.push(new THREE.Vector3(p.x, 0.02, p.z));
  }
  const geom = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 2 });
  return new THREE.Line(geom, mat);
}

/* ---------------- lon/lat helpers ---------------- */
function metersPerDegLat(){ return 111320.0; }
function metersPerDegLon(lat){ return Math.cos(lat * Math.PI/180) * 111320.0; }
function lonLatToPosition(lon, lat, centerLon, centerLat){
  const dx = (lon - centerLon) * metersPerDegLon(centerLat);
  const dz = (lat - centerLat) * metersPerDegLat();
  return { x: dx, y:0, z: -dz };
}

/* ---------------- tile helpers ---------------- */
function lonLatToTile(lon, lat, zoom){
  const latRad = lat * Math.PI/180;
  const n = Math.pow(2, zoom);
  const x = Math.floor((lon + 180) / 360 * n);
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

function tileSizeMeters(lat, zoom){
  const R = 6378137.0;
  const metersPerPixel = (Math.cos(lat * Math.PI/180) * 2 * Math.PI * R) / (Math.pow(2, zoom) * 256.0);
  return metersPerPixel * 256.0;
}

async function createStitchedTileTexture(tmpl, z, cx, cy, grid){
  const tilePx = 256;
  const sizePx = grid * tilePx;
  const canvas = document.createElement('canvas');
  canvas.width = sizePx; canvas.height = sizePx;
  const ctx = canvas.getContext('2d');
  const half = Math.floor(grid/2);
  const promises = [];

  for (let dy = -half; dy <= half; dy++) {
    for (let dx = -half; dx <= half; dx++) {
      const tx = cx + dx, ty = cy + dy;
      const url = tmpl.replace('{z}', z).replace('{x}', tx).replace('{y}', ty);
      promises.push(new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { ctx.drawImage(img, (dx+half)*tilePx, (dy+half)*tilePx); res(); };
        img.onerror = () => rej(new Error('Tile load failed: ' + url));
        img.src = url;
      }));
    }
  }

  await Promise.all(promises);
  const tex = new THREE.CanvasTexture(canvas);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  return tex;
}

/* ---------------- misc ---------------- */
function clearPlacedObjects(){
  for (const o of placedObjects) scene.remove(o);
  placedObjects = [];
  statusEl.textContent = '状態: 配置をクリアしました';
}
window.clearPlacedObjects = clearPlacedObjects;

</script>
</body>
</html>
