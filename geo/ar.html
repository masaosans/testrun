<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Fixed</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            color: white; 
            font-family: Arial; 
            text-align: center;
        }
        #arCanvas {
            width: 100vw;
            height: 100vh;
            display: none;
            background: transparent !important;
        }
        button {
            padding: 12px 20px;
            font-size: 18px;
            margin: 10px;
        }
    </style>
</head>
<body>

<h1>WebXR AR Test</h1>
<div id="info">Ready</div>
<button onclick="startAR()">Start AR</button>

<canvas id="arCanvas"></canvas>

<script>
let session = null;
let gl = null;
let refSpace = null;

function log(msg) {
    document.getElementById('info').textContent = msg;
    console.log(msg);
}

async function startAR() {
    if (!navigator.xr) {
        log("WebXR not supported");
        return;
    }

    try {
        // ▼ 必須: camera-access / local / dom-overlay
        session = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["camera-access", "local"],
            optionalFeatures: ["dom-overlay"],
            domOverlay: { root: document.body }
        });

        log("AR session started");

        const canvas = document.getElementById("arCanvas");
        canvas.style.display = "block";

        // ▼ WebGL context（α必須）
        gl = canvas.getContext("webgl", {
            xrCompatible: true,
            alpha: true
        });

        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;

        // ▼ XR layer（α必須）
        const layer = new XRWebGLLayer(session, gl, { alpha: true });
        session.updateRenderState({ baseLayer: layer });

        refSpace = await session.requestReferenceSpace("local");

        // 描画開始
        session.requestAnimationFrame(onXRFrame);

    } catch (err) {
        log("Error: " + err.message);
    }
}

function onXRFrame(t, frame) {
    const layer = session.renderState.baseLayer;

    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
    gl.clearColor(0.0, 0.0, 0.0, 0.0); // ▼ transparent
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const pose = frame.getViewerPose(refSpace);

    if (pose) {
        for (const view of pose.views) {
            const vp = layer.getViewport(view);
            gl.viewport(vp.x, vp.y, vp.width, vp.height);

            drawTriangle(view);
        }
    }

    session.requestAnimationFrame(onXRFrame);
}

// ▼ 超シンプルな三角形描画
function drawTriangle(view) {
    const vertices = new Float32Array([
        0.0,  0.3, -1.0,
       -0.3, -0.3, -1.0,
        0.3, -0.3, -1.0
    ]);

    const colors = new Float32Array([
        1.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0
    ]);

    const vsSource = `
        attribute vec3 aPosition;
        attribute vec4 aColor;
        uniform mat4 uProjection;
        varying vec4 vColor;
        void main() {
            gl_Position = uProjection * vec4(aPosition, 1.0);
            vColor = aColor;
        }
    `;

    const fsSource = `
        precision mediump float;
        varying vec4 vColor;
        void main() {
            gl_FragColor = vColor;
        }
    `;

    const prog = createProgram(vsSource, fsSource);
    gl.useProgram(prog);

    const posBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(prog, "aPosition");
    gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(posLoc);

    const colBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

    const colLoc = gl.getAttribLocation(prog, "aColor");
    gl.vertexAttribPointer(colLoc, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(colLoc);

    const projLoc = gl.getUniformLocation(prog, "uProjection");
    gl.uniformMatrix4fv(projLoc, false, view.projectionMatrix);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
}

function createProgram(vs, fs) {
    const vShader = compile(gl.VERTEX_SHADER, vs);
    const fShader = compile(gl.FRAGMENT_SHADER, fs);
    const prog = gl.createProgram();
    gl.attachShader(prog, vShader);
    gl.attachShader(prog, fShader);
    gl.linkProgram(prog);
    return prog;
}

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
}

</script>
</body>
</html>
