<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple WebXR AR</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial; background: #222; color: white; text-align: center; }
        button { padding: 15px 30px; margin: 10px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer; }
        #startBtn { background: #4CAF50; color: white; }
        #stopBtn { background: #f44336; color: white; }
        #moveBtn { background: #2196F3; color: white; }
        #arView { width: 100%; height: 400px; background: black; margin: 20px 0; display: none; }
        #arView.active { display: block; }
        #info { margin: 10px; padding: 10px; background: #333; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>Simple WebXR AR</h1>
    <div id="info">ARを開始してください</div>
    <div>
        <button id="startBtn" onclick="startAR()">AR開始</button>
        <button id="stopBtn" onclick="stopAR()" disabled>停止</button>
        <button id="moveBtn" onclick="moveCube()" disabled>立方体を近づける</button>
    </div>
    <div id="arView">
        <canvas id="arCanvas"></canvas>
    </div>

    <script>
        let session = null;
        let gl = null;
        let cubeDistance = -2.0;

        async function startAR() {
            if (!navigator.xr) {
                showInfo('WebXR非対応');
                return;
            }

            try {
                session = await navigator.xr.requestSession('immersive-ar');
                showInfo('AR開始成功');
                
                const canvas = document.getElementById('arCanvas');
                setupWebGL(canvas);
                
                const glLayer = new XRWebGLLayer(session, gl);
                await session.updateRenderState({ baseLayer: glLayer });
                
                document.getElementById('arView').classList.add('active');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('moveBtn').disabled = false;
                
                startRendering();
                
            } catch (error) {
                showInfo('エラー: ' + error.message);
            }
        }

        function setupWebGL(canvas) {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            gl = canvas.getContext('webgl', { xrCompatible: true });
            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(0, 0, 0, 0);
        }

        function startRendering() {
            const renderLoop = (time, frame) => {
                if (!session) return;
                
                const pose = frame.getViewerPose(session.renderState.referenceSpace);
                const glLayer = session.renderState.baseLayer;
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                if (pose) {
                    pose.views.forEach(view => {
                        if (view.viewport) {
                            gl.viewport(view.viewport.x, view.viewport.y, view.viewport.width, view.viewport.height);
                            drawCube(view, time);
                        }
                    });
                }
                
                session.requestAnimationFrame(renderLoop);
            };
            
            session.requestAnimationFrame(renderLoop);
        }

        function drawCube(view, time) {
            // シンプルな立方体の描画
            const vertices = new Float32Array([
                -0.3, -0.3,  0.3,  0.5, -0.3,  0.3,  0.5,  0.5,  0.3, -0.3,  0.5,  0.3, // 前面
                -0.3, -0.3, -0.3, -0.3,  0.5, -0.3,  0.5,  0.5, -0.3,  0.5, -0.3, -0.3, // 背面
            ]);
            
            const colors = new Float32Array([
                1,0,0,1, 1,0,0,1, 1,0,0,1, 1,0,0,1, // 前面(赤)
                0,1,0,1, 0,1,0,1, 0,1,0,1, 0,1,0,1, // 背面(緑)
            ]);
            
            const indices = new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7]);
            
            // バッファ設定
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            // シンプルなシェーダー
            const vs = `attribute vec4 position; attribute vec4 color; uniform mat4 proj; uniform mat4 model; varying vec4 vColor; void main() { gl_Position = proj * model * position; vColor = color; }`;
            const fs = `varying vec4 vColor; void main() { gl_FragColor = vColor; }`;
            
            const program = createProgram(vs, fs);
            gl.useProgram(program);
            
            // 属性設定
            const positionLoc = gl.getAttribLocation(program, "position");
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);
            
            const colorLoc = gl.getAttribLocation(program, "color");
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(colorLoc);
            
            // 行列設定
            const rotation = time * 0.001;
            const modelMatrix = [
                Math.cos(rotation), 0, Math.sin(rotation), 0,
                0, 1, 0, 0,
                -Math.sin(rotation), 0, Math.cos(rotation), 0,
                0, 0, cubeDistance, 1
            ];
            
            const projLoc = gl.getUniformLocation(program, "proj");
            const modelLoc = gl.getUniformLocation(program, "model");
            
            gl.uniformMatrix4fv(projLoc, false, view.projectionMatrix);
            gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
            
            // 描画
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function createProgram(vsSource, fsSource) {
            const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            return program;
        }

        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function moveCube() {
            cubeDistance += 0.5;
            if (cubeDistance > -0.5) cubeDistance = -0.5;
            showInfo('距離: ' + cubeDistance.toFixed(1) + 'm');
        }

        async function stopAR() {
            if (session) {
                await session.end();
                session = null;
            }
            document.getElementById('arView').classList.remove('active');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('moveBtn').disabled = true;
            showInfo('AR停止');
            cubeDistance = -2.0;
        }

        function showInfo(msg) {
            document.getElementById('info').textContent = msg;
            console.log(msg);
        }

        // 初期チェック
        if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                if (!supported) showInfo('AR非対応デバイス');
            });
        }
    </script>
</body>
</html>
