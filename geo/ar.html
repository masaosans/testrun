<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>AR 古地図 + 行政界 — 完全版</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>

<!-- Three.js r128 -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>

<!-- Debug console -->
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>

<style>
html,body {
  margin:0;
  padding:0;
  overflow:hidden;
  height:100%;
  background: transparent;
  font-family: system-ui, "Noto Sans JP", sans-serif;
}

#ui {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 10001;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 12px;
  border-radius: 12px;
  width: 300px;
}

#ui button, #ui input, #ui select {
  width: 100%;
  margin-top: 8px;
  padding: 6px;
  border-radius: 6px;
  border: none;
}

#status {
  position: fixed;
  bottom: 10px;
  left: 10px;
  z-index: 10001;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 14px;
}
</style>
</head>

<body>

<!-- UI / DOM Overlay -->
<div id="ui">
  <div style="font-weight:700;">AR 古地図 + 行政界</div>

  <button id="start-ar">AR開始</button>

  <label>古地図タイルテンプレ
    <input id="tile-template"
      value="https://aginfo.cgk.affrc.go.jp/ws/tmc/1.0.0/200k/map/{z}/{x}/{y}.png">
  </label>

  <label>タイルズーム
    <input id="tile-zoom" value="14">
  </label>

  <label>ステッチ
    <select id="tile-grid">
      <option>1</option>
      <option selected>3</option>
      <option>5</option>
    </select>
  </label>

  <label>行政界 GeoJSON URL
    <input id="geojson-url"
      value="https://raw.githubusercontent.com/geolonia/japanese-admin-boundaries/master/dist/japan.geojson">
  </label>

  <button id="load-geo">行政界ロード</button>
  <button id="clear-all">配置クリア</button>
</div>

<div id="status">状態: 待機</div>

<script>
// =========================================
// Three.js + AR 初期化
// =========================================
let scene, camera, renderer;
let reticle;
let xrRefSpace = null;
let hitTestSource = null;
let hitTestSourceRequested = false;
let lastReticleMatrix = null;

let placedObjects = [];
let adminGeoJSON = null;

const statusEl = document.getElementById("status");

// -----------------------------------------
function initThree() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70,
    window.innerWidth / window.innerHeight,
    0.01, 100);

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.xr.enabled = true;

  document.body.appendChild(renderer.domElement);

  // Light
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  // Reticle
  const geo = new THREE.RingGeometry(0.05, 0.07, 32).rotateX(-Math.PI / 2);
  const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  reticle = new THREE.Mesh(geo, mat);
  reticle.visible = false;
  reticle.matrixAutoUpdate = false;
  scene.add(reticle);
}
initThree();

// =========================================
// AR開始
// =========================================
document.getElementById("start-ar").onclick = startAR;

async function startAR() {
  if (!navigator.xr) {
    alert("WebXR未対応です");
    return;
  }

  const supported = await navigator.xr.isSessionSupported("immersive-ar");
  if (!supported) {
    alert("このデバイスはARをサポートしていません");
    return;
  }

  const session = await navigator.xr.requestSession("immersive-ar", {
    requiredFeatures: ["hit-test", "dom-overlay"],
    domOverlay: { root: document.body }
  });

  renderer.xr.setSession(session);

  xrRefSpace = await session.requestReferenceSpace("local")
    .catch(_ => session.requestReferenceSpace("viewer"));

  session.addEventListener("select", onSelect);
  session.addEventListener("end", () => {
    hitTestSourceRequested = false;
    hitTestSource = null;
    renderer.setAnimationLoop(null);
  });

  renderer.setAnimationLoop(renderAR);
  statusEl.textContent = "状態: ARセッション開始";
}

// =========================================
// ARフレーム
// =========================================
function renderAR(timestamp, frame) {
  if (frame) {
    const session = frame.session;

    if (!hitTestSourceRequested) {
      session.requestReferenceSpace("viewer").then(viewerSpace => {
        session.requestHitTestSource({ space: viewerSpace })
          .then(src => hitTestSource = src);
      });
      hitTestSourceRequested = true;
    }

    if (hitTestSource) {
      const hits = frame.getHitTestResults(hitTestSource);
      if (hits.length > 0) {
        const pose = hits[0].getPose(xrRefSpace);
        if (pose) {
          reticle.visible = true;
          const m = new THREE.Matrix4().fromArray(pose.transform.matrix);
          reticle.matrix.copy(m);
          lastReticleMatrix = m.clone();
        }
      } else {
        reticle.visible = false;
        lastReticleMatrix = null;
      }
    }
  }
  renderer.render(scene, camera);
}

// =========================================
// タップで古地図＋行政界を配置
// =========================================
async function onSelect() {
  if (!lastReticleMatrix || !reticle.visible) {
    statusEl.textContent = "状態: 配置できません";
    return;
  }

  // 1. 現在地取得
  let centerLat = 35.681236, centerLon = 139.767125;

  try {
    const pos = await new Promise((res, rej) =>
      navigator.geolocation.getCurrentPosition(res, rej, {
        enableHighAccuracy: true, timeout: 6000
      })
    );
    centerLat = pos.coords.latitude;
    centerLon = pos.coords.longitude;
  } catch (e) {}

  const zoom = parseInt(document.getElementById("tile-zoom").value);
  const grid = parseInt(document.getElementById("tile-grid").value);
  const tmpl = document.getElementById("tile-template").value;

  statusEl.textContent = "状態: タイル取得中…";

  // タイル座標へ
  const tile = lonLatToTile(centerLon, centerLat, zoom);
  let tex;

  try {
    tex = await createStitchedTileTexture(tmpl, zoom, tile.x, tile.y, grid);
  } catch (e) {
    alert("タイル取得失敗\n" + e.message);
    return;
  }

  const size = tileSizeMeters(centerLat, zoom) * grid;
  const geo = new THREE.PlaneGeometry(size, size);
  const mat = new THREE.MeshStandardMaterial({
    map: tex,
    side: THREE.DoubleSide
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.matrixAutoUpdate = false;
  mesh.matrix.copy(lastReticleMatrix);

  scene.add(mesh);
  placedObjects.push(mesh);

  // 行政界
  if (adminGeoJSON) {
    drawGeoJSON(centerLon, centerLat, lastReticleMatrix);
  }

  statusEl.textContent = "状態: 配置完了";
}

// =========================================
// GeoJSON ロード
// =========================================
document.getElementById("load-geo").onclick = async () => {
  const url = document.getElementById("geojson-url").value;
  statusEl.textContent = "状態: GeoJSON取得中";

  try {
    const res = await fetch(url);
    adminGeoJSON = await res.json();
    statusEl.textContent = "状態: GeoJSON読込完了";
  } catch (e) {
    alert("GeoJSON取得失敗\n" + e.message);
  }
};

// =========================================
// 緯度経度 <-> XYZ
// =========================================
function metersPerDegLat() { return 111320; }
function metersPerDegLon(lat) { return Math.cos(lat * Math.PI/180) * 111320; }

function lonLatToPosition(lon, lat, cx, cy) {
  return new THREE.Vector3(
    (lon - cx) * metersPerDegLon(cy),
    0,
    -(lat - cy) * metersPerDegLat()
  );
}

// ------------------------------------------
function drawGeoJSON(cx, cy, baseMatrix) {
  const group = new THREE.Group();
  group.matrixAutoUpdate = false;
  group.matrix.copy(baseMatrix);

  for (const f of adminGeoJSON.features) {
    const g = f.geometry;
    if (!g) continue;

    if (g.type === "Polygon") {
      const obj = geoPolygon(g.coordinates, cx, cy);
      if (obj) group.add(obj);

    } else if (g.type === "MultiPolygon") {
      for (const poly of g.coordinates) {
        const obj = geoPolygon(poly, cx, cy);
        if (obj) group.add(obj);
      }
    }
  }

  scene.add(group);
  placedObjects.push(group);
}

// ------------------------------------------
function geoPolygon(poly, cx, cy) {
  const ring = poly[0];
  if (!ring) return null;

  const pts = ring.map(r => {
    const p = lonLatToPosition(r[0], r[1], cx, cy);
    return new THREE.Vector3(p.x, 0.05, p.z);
  });

  const geom = new THREE.BufferGeometry().setFromPoints(pts);
  const line = new THREE.LineLoop(
    geom,
    new THREE.LineBasicMaterial({ color: 0x00ff00 })
  );

  return line;
}

// =========================================
// タイル処理
// =========================================
function lonLatToTile(lon, lat, zoom) {
  const latRad = lat * Math.PI / 180;
  const n = 2 ** zoom;
  const x = Math.floor((lon + 180) / 360 * n);
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

function tileSizeMeters(lat, zoom) {
  const R = 6378137.0;
  const mpp = Math.cos(lat * Math.PI/180) * 2 * Math.PI * R / (2**zoom * 256);
  return mpp * 256;
}

async function createStitchedTileTexture(tmpl, z, cx, cy, grid) {
  const tilePx = 256;
  const size = grid * tilePx;

  const cvs = document.createElement("canvas");
  cvs.width = size;
  cvs.height = size;
  const ctx = cvs.getContext("2d");

  const half = Math.floor(grid/2);
  const ps = [];

  for (let dy=-half; dy<=half; dy++) {
    for (let dx=-half; dx<=half; dx++) {
      const x = cx + dx;
      const y = cy + dy;
      const url = tmpl
        .replace("{z}", z)
        .replace("{x}", x)
        .replace("{y}", y);

      ps.push(new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          ctx.drawImage(img,
            (dx+half)*tilePx,
            (dy+half)*tilePx);
          res();
        };
        img.onerror = () => rej(new Error("タイル取得失敗: " + url));
        img.src = url;
      }));
    }
  }

  await Promise.all(ps);

  const tex = new THREE.CanvasTexture(cvs);
  tex.needsUpdate = true;
  return tex;
}

// =========================================
// 配置削除
// =========================================
document.getElementById("clear-all").onclick = () => {
  placedObjects.forEach(o => scene.remove(o));
  placedObjects = [];
  statusEl.textContent = "状態: クリア完了";
};
</script>

</body>
</html>
