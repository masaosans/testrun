<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Dynamic OSM 3D (Overpass tiles) - Example</title>
<style>body{margin:0;overflow:hidden;font-family:Arial,Helvetica;}#info{position:absolute;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px;font-size:13px}</style>
</head>
<body>
<div id="info">ドラッグで移動 / ホイールでズーム。状況はコンソール参照。<br>Tile Z=16, radius = <span id="rad">1</span></div>

<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===========================
   設定
   =========================== */
const ZOOM = 16;                    // タイルズーム（OverpassクエリBBOXはこのZのタイル単位）
let LOAD_RADIUS = 1;                // カメラ中心から何タイル読み込むか（表示中に調整可）
document.getElementById('rad').textContent = LOAD_RADIUS;

const TILE_SIZE_M = 200;            // Z=16 をおおよそ 200m と想定（WebMercator の実寸に合わせる）
const MAX_CONCURRENT_FETCH = 3;     // Overpass 同時接続数
const OVERPASS_RETRY = 2;           // 再試行回数
const OVERPASS_DELAY_MS = 400;      // タイル間フェッチ遅延（多少あると安定する）

// Overpass POST or GET? Use POST for bbox stability
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

/* ===========================
   WebMercator ユーティリティ
   =========================== */
const R = 6378137; // earth radius meters

function lonToMercX(lon){
  return R * lon * Math.PI/180;
}
function latToMercY(lat){
  const rad = lat * Math.PI/180;
  return R * Math.log(Math.tan(Math.PI/4 + rad/2));
}
function mercXToLon(x){ return (x / R) * 180 / Math.PI; }
function mercYToLat(y){ return (2 * Math.atan(Math.exp(y / R)) - Math.PI/2) * 180 / Math.PI; }

// tile <-> latlon helpers
function tile2lon(x,z){ return x / Math.pow(2,z) * 360 - 180; }
function tile2lat(y,z){
  const n = Math.PI - 2 * Math.PI * y / Math.pow(2,z);
  return (180 / Math.PI) * Math.atan(Math.sinh(n));
}
function lonLatToMerc(lon, lat){ return {x: lonToMercX(lon), y: latToMercY(lat)}; }
function mercToWorld(x,y, origin){ // origin in merc coords
  return { x: x - origin.x, z: -(y - origin.y) }; // Three.js: x right, z forward(Neg because mercY increases north)
}

/* ===========================
   Three.js 初期化
   =========================== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa8dffb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
camera.position.set(0, 800, 1200);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

/* ライト */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(500,1000,500); scene.add(dir);

/* 床の基準原点（mercator） — 東京中心を初期原点に */
const INIT_CENTER_LON = 139.6917;
const INIT_CENTER_LAT = 35.6895;
const ORIGIN_M = lonLatToMerc(INIT_CENTER_LON, INIT_CENTER_LAT); // world origin at Tokyo center

/* グローバルキャッシュ */
const loadedTiles = new Map(); // key = `${x}_${y}` -> {group, lastUsed, bbox}
const fetchQueue = [];
let activeFetches = 0;
const geoCache = new Map();   // url -> json
const imgCache = new Map();   // tileUrl -> texture

/* テクスチャ（窓） */
const windowTex = new THREE.TextureLoader().load("https://i.imgur.com/4NJx7G9.png");

/* ===========================
   タイル / Overpass 関連
   =========================== */
function tileBBoxLonLat(x,y,z){
  return {
    west: tile2lon(x,z),
    north: tile2lat(y,z),
    east: tile2lon(x+1,z),
    south: tile2lat(y+1,z)
  };
}

function bboxToOverpassQuery(bbox){
  // Overpass expects: south,west,north,east
  return `[out:json][timeout:25];
(
  way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
);
(._;>;);
out geom;`;
}

async function fetchOverpassForTile(x,y,z, tries=0){
  const key = `${x}_${y}`;
  if(geoCache.has(key)) return geoCache.get(key);
  const bbox = tileBBoxLonLat(x,y,z);
  const query = bboxToOverpassQuery(bbox);

  try {
    activeFetches++;
    // use POST to avoid url length issues
    const res = await fetch(OVERPASS_URL, { method:"POST", body: query });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    geoCache.set(key, { bbox, json });
    return { bbox, json };
  } catch(err){
    console.warn("Overpass fetch error", x,y, err);
    if(tries < OVERPASS_RETRY){
      await new Promise(r=>setTimeout(r, 500 * Math.pow(2, tries)));
      return fetchOverpassForTile(x,y,z, tries+1);
    } else {
      return null;
    }
  } finally {
    activeFetches--;
  }
}

/* enqueue fetch with concurrency control */
function enqueueFetch(fn){
  return new Promise((resolve)=> {
    fetchQueue.push({fn, resolve});
    processQueue();
  });
}
function processQueue(){
  if(activeFetches >= MAX_CONCURRENT_FETCH) return;
  const job = fetchQueue.shift();
  if(!job) return;
  job.fn().then(result => job.resolve(result)).finally(()=> {
    setTimeout(processQueue, OVERPASS_DELAY_MS); // small delay to be gentle
  });
}

/* ===========================
   タイル表示 / アンロード
   =========================== */
function addTileToScene(x,y,z, data){ // data: {bbox, json}
  const key = `${x}_${y}`;
  if(loadedTiles.has(key)) return;

  const group = new THREE.Group();
  group.userData = { x, y, z, bbox: data.bbox };
  // position will be relative to ORIGIN_M

  // add floor (OSM tile image)
  const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
  let texPromise;
  if(imgCache.has(tileUrl)){
    texPromise = Promise.resolve(imgCache.get(tileUrl));
  } else {
    texPromise = new Promise((res, rej)=>{
      new THREE.TextureLoader().load(tileUrl, tex => {
        tex.flipY = false;
        imgCache.set(tileUrl, tex);
        res(tex);
      }, undefined, err => { console.warn("tile image load err", tileUrl, err); res(null); });
    });
  }

  texPromise.then(tex=>{
    if(tex){
      const mercW = lonToMercX(data.bbox.east) - lonToMercX(data.bbox.west);
      const mercH = latToMercY(data.bbox.north) - latToMercY(data.bbox.south);
      // convert to world units relative to origin
      const worldCenter = mercToWorld((lonToMercX(data.bbox.west)+lonToMercX(data.bbox.east))/2,
                                      (latToMercY(data.bbox.south)+latToMercY(data.bbox.north))/2,
                                      ORIGIN_M);
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(mercW, mercH),
        new THREE.MeshPhongMaterial({ map: tex })
      );
      plane.rotation.x = -Math.PI/2;
      plane.position.set(worldCenter.x, 0, worldCenter.z);
      group.add(plane);
    }
  });

  // add buildings from Overpass json
  const els = data.json.elements || [];
  els.forEach(el=>{
    if(el.type !== "way" || !el.geometry) return;
    const shape = new THREE.Shape();
    el.geometry.forEach((pt, idx)=>{
      const m = lonLatToMerc(pt.lon, pt.lat);
      const world = mercToWorld(m.x, m.y, ORIGIN_M);
      if(idx === 0) shape.moveTo(world.x, world.z);
      else shape.lineTo(world.x, world.z);
    });

    const tags = el.tags || {};
    let height = 10;
    if(tags.height) { height = parseFloat(String(tags.height).replace('m','')) || height; }
    else if(tags["building:levels"]) { height = (parseFloat(tags["building:levels"])||1) * 3; }

    const g = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false });
    const mat = new THREE.MeshPhongMaterial({ map: windowTex, color: 0xccccff });
    const mesh = new THREE.Mesh(g, mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.position.y = height/2;
    group.add(mesh);
  });

  scene.add(group);
  loadedTiles.set(key, { group, lastUsed: Date.now(), bbox: data.bbox });
  console.log(`Tile added ${key}`);
}

/* アンロード */
function unloadFarTiles(centerTileX, centerTileY){
  const keys = Array.from(loadedTiles.keys());
  for(const key of keys){
    const [tx, ty] = key.split("_").map(n=>parseInt(n,10));
    if(Math.abs(tx - centerTileX) > LOAD_RADIUS + 1 || Math.abs(ty - centerTileY) > LOAD_RADIUS + 1){
      const info = loadedTiles.get(key);
      scene.remove(info.group);
      // dispose geometries / materials for memory
      info.group.traverse(obj=>{
        if(obj.geometry) { obj.geometry.dispose(); }
        if(obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
          else obj.material.dispose();
        }
      });
      loadedTiles.delete(key);
      console.log(`Tile unloaded ${key}`);
    }
  }
}

/* ===========================
   カメラ位置 ⇄ 緯度経度
   - We place the world origin at ORIGIN_M (Tokyo center).
   - We need a way to convert camera position (world coords) back to lon/lat to find tile indices.
   =========================== */
function worldToMerc(xworld,zworld){
  // inverse of mercToWorld: world.x = mx - origin.x, world.z = -(my - origin.y)
  const mx = xworld + ORIGIN_M.x;
  const my = -(zworld) + ORIGIN_M.y;
  return {x: mx, y: my};
}
function mercToLonLat(mx,my){
  return { lon: mercXToLon(mx), lat: mercYToLat(my) };
}
function cameraToLonLat(){
  // use camera target (controls.target) as center
  const tx = controls.target.x;
  const tz = controls.target.z;
  const m = worldToMerc(tx, tz);
  return mercToLonLat(m.x, m.y);
}

/* ===========================
   タイル更新ロジック（レート制御）
   - カメラの中心（controls.target）を基準に LOAD_RADIUS の範囲のタイルを維持
   - fetch はキューに入れて同時 MAX_CONCURRENT_FETCH 件まで
   =========================== */
let lastUpdate = 0;
const MIN_UPDATE_INTERVAL = 1200; // ms

async function updateTilesAroundCamera(){
  const now = performance.now();
  if(now - lastUpdate < MIN_UPDATE_INTERVAL) return;
  lastUpdate = now;

  const center = cameraToLonLat();
  const cx = lonToTileX(center.lon, ZOOM);
  const cy = latToTileY(center.lat, ZOOM);

  unloadFarTiles(cx, cy);

  for(let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++){
    for(let dy = -LOAD_RADIUS; dy <= LOAD_RADIUS; dy++){
      const tx = cx + dx;
      const ty = cy + dy;
      const key = `${tx}_${ty}`;
      if(loadedTiles.has(key)) {
        loadedTiles.get(key).lastUsed = Date.now();
        continue;
      }
      // enqueue fetch
      enqueueFetch(async ()=> {
        const res = await fetchOverpassForTile(tx, ty, ZOOM);
        if(res) addTileToScene(tx, ty, ZOOM, res);
        return res;
      });
    }
  }
}

/* helpers: tile index from lon/lat */
function lonToTileX(lon, zoom){ return Math.floor((lon + 180) / 360 * Math.pow(2,zoom)); }
function latToTileY(lat, zoom){
  const a = Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180));
  return Math.floor((1 - a/Math.PI) / 2 * Math.pow(2,zoom));
}

/* ===========================
   アニメーションループ
   =========================== */
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  updateTilesAroundCamera();
  renderer.render(scene, camera);
}
animate();

/* ウィンドウリサイズ */
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* UI: radius control by keys (+/-) */
window.addEventListener('keydown', (e)=>{
  if(e.key === "+") { LOAD_RADIUS = Math.min(4, LOAD_RADIUS+1); document.getElementById('rad').textContent = LOAD_RADIUS; }
  if(e.key === "-") { LOAD_RADIUS = Math.max(0, LOAD_RADIUS-1); document.getElementById('rad').textContent = LOAD_RADIUS; }
});

/* ===========================
   ログヒント
   =========================== */
console.log("Dynamic OSM viewer started. Use + / - to change load radius. Controls: drag to pan, wheel to zoom.");
</script>
</body>
</html>
