<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>OSM Buildings + Roof + LOD</title>
<style>
body { margin: 0; overflow: hidden; }
#infoLabel {
  position: absolute;
  top: 10px;
  left: 10px;
  color: white;
  background: rgba(0,0,0,0.4);
  padding: 6px 10px;
  border-radius: 4px;
  pointer-events:none;
  font-family: sans-serif;
}
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ---------------------------------------------------
//  基本設定
// ---------------------------------------------------
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 20000);
camera.position.set(0,200,400);

let renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// 光源
let light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(100,300,200);
light.castShadow = true;
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// ---------------------------------------------------
//  ツール：経度緯度 → メルカトル → ワールド
// ---------------------------------------------------
function lonLatToMerc(lon, lat) {
    const R = 6378137;
    const x = R * THREE.MathUtils.degToRad(lon);
    const y = R * Math.log(Math.tan(Math.PI/4 + THREE.MathUtils.degToRad(lat)/2));
    return {x, y};
}

function mercToWorld(mx, my) {
    // 同一スケール
    return { x: mx/10, z: -my/10 };
}

function lonLatToWorld(lon,lat) {
    const m = lonLatToMerc(lon,lat);
    return mercToWorld(m.x,m.y);
}

// ---------------------------------------------------
//  LOD用：簡易ビル（Box）
// ---------------------------------------------------
function createBoxLODFromWay(way) {

    if (!way.geometry || !way.geometry.type || !way.geometry.coordinates) return null;

    let rings = null;
    if (way.geometry.type === "Polygon") {
        rings = way.geometry.coordinates[0];
    } else if (way.geometry.type === "MultiPolygon") {
        rings = way.geometry.coordinates[0][0];
    } else {
        return null;
    }
    if (!Array.isArray(rings) || rings.length < 3) return null;

    const pts = rings.map(p=>lonLatToWorld(p[0],p[1]));

    // centroid
    let cx=0, cz=0;
    for (const p of pts){ cx+=p.x; cz+=p.z;}
    cx /= pts.length;
    cz /= pts.length;

    // size
    let minX=Infinity,maxX=-Infinity,minZ=Infinity,maxZ=-Infinity;
    for(const p of pts){
        minX=Math.min(minX,p.x);
        maxX=Math.max(maxX,p.x);
        minZ=Math.min(minZ,p.z);
        maxZ=Math.max(maxZ,p.z);
    }
    const w = maxX - minX;
    const d = maxZ - minZ;

    const tags = way.tags || {};
    const h = tags.height ? parseFloat(tags.height) : 10;

    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color:0x999999 });
    const mesh = new THREE.Mesh(geo,mat);
    mesh.position.set(cx, h/2, cz);
    return mesh;
}

// ---------------------------------------------------
//  屋根付き Extrude 確定版
// ---------------------------------------------------
function createExtrudeMeshWithRoof(way) {

    if (!way.geometry || !way.geometry.type || !way.geometry.coordinates) return null;

    let rings = null;

    if (way.geometry.type === "Polygon") {
        rings = way.geometry.coordinates[0];
    } else if (way.geometry.type === "MultiPolygon") {
        rings = way.geometry.coordinates[0][0];
    } else {
        return null;
    }

    if (!Array.isArray(rings) || rings.length < 3) return null;

    // world
    const pts = rings.map(p => lonLatToWorld(p[0],p[1]));

    // centroid
    let cx=0, cz=0;
    for(const p of pts){ cx+=p.x; cz+=p.z; }
    cx/=pts.length; cz/=pts.length;

    // shape (centroid基準ローカル)
    const shape = new THREE.Shape( pts.map(p => new THREE.Vector2(p.x-cx, p.z-cz)) );

    const tags = way.tags || {};
    const height = tags.height ? parseFloat(tags.height) : 10;

    // Extrude
    const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: height,
        bevelEnabled: false
    });
    const material = new THREE.MeshStandardMaterial({ color:0xcccccc });
    const mesh = new THREE.Mesh(geometry,material);

    // roof
    const roofGeom = new THREE.ShapeGeometry(shape);
    roofGeom.translate(0,height,0);
    const roof = new THREE.Mesh(roofGeom, new THREE.MeshStandardMaterial({color:0xbbbbbb}));

    mesh.add(roof);

    mesh.position.set(cx,0,cz);
    return mesh;
}

// ---------------------------------------------------
//  建物 LOD
// ---------------------------------------------------
function createBuildingLOD(way) {

    const tags = way.tags || {};
    if (!tags.building) return null;

    if (!way.geometry || !way.geometry.type) return null;

    if (way.geometry.type !== "Polygon" && way.geometry.type !== "MultiPolygon") {
        return null;
    }

    const lod = new THREE.LOD();

    const m1 = createExtrudeMeshWithRoof(way);
    if (m1) lod.addLevel(m1, 150);

    const m2 = createBoxLODFromWay(way);
    if (m2) lod.addLevel(m2, 400);

    if (lod.levels.length === 0) return null;
    return lod;
}

// ---------------------------------------------------
// クリックラベル
// ---------------------------------------------------
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

let labelSprite = null;

function makeLabelSprite(text) {
    const canvas = document.createElement("canvas");
    canvas.width = 512; canvas.height = 256;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0,0,512,256);

    ctx.fillStyle = "white";
    ctx.font = "48px sans-serif";
    ctx.fillText(text, 20, 140);

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(80,40,1);
    return sprite;
}

function onClickOrTouch(event){
    let x,y;
    if(event.touches){
        x = event.touches[0].clientX;
        y = event.touches[0].clientY;
    } else {
        x = event.clientX;
        y = event.clientY;
    }

    mouse.x = (x / window.innerWidth)*2 -1;
    mouse.y = -(y / window.innerHeight)*2 +1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);

    if(intersects.length > 0){
        const obj = intersects[0].object;
        if(obj.userData && obj.userData.name){
            if(labelSprite) scene.remove(labelSprite);
            labelSprite = makeLabelSprite(obj.userData.name);

            const pos = intersects[0].point;
            labelSprite.position.copy(pos);
            labelSprite.position.y += 30; // ちょっと高くする
            scene.add(labelSprite);
        }
    }
}

window.addEventListener("click", onClickOrTouch);
window.addEventListener("touchstart", onClickOrTouch);

// ---------------------------------------------------
//  OSM 建物読み込み (あなたの既存タイル読み込みロジックを使用)
// ---------------------------------------------------

async function loadTileJson(x,y,z){
    const url = `your-osm-building-tile-endpoint/${z}/${x}/${y}.json`;
    const res = await fetch(url);
    if(!res.ok) return null;
    return await res.json();
}

async function addTileToScene(x,y,z){
    const data = await loadTileJson(x,y,z);
    if(!data || !data.elements) return;

    for(const way of data.elements){
        const b = createBuildingLOD(way);
        if(!b) continue;

        // 名前を userData に入れておく
        if(way.tags && way.tags.name){
            b.userData.name = way.tags.name;
        }

        scene.add(b);
    }
}

// ---------------------------------------------------
//  カメラ移動に応じたタイル更新
// ---------------------------------------------------
let lastCamX=0,lastCamZ=0;

function updateTilesAroundCamera(){
    const cx = camera.position.x;
    const cz = camera.position.z;

    const dx = Math.abs(cx - lastCamX);
    const dz = Math.abs(cz - lastCamZ);

    if(dx < 200 && dz < 200) return;
    lastCamX = cx; lastCamZ = cz;

    // 仮: 中心タイル固定（必要ならあなたのタイル管理ロジックへ戻してOK）
    const tx = 1, ty = 1, tz = 16;
    addTileToScene(tx,ty,tz);
}

// ---------------------------------------------------
//  アニメーション
// ---------------------------------------------------
function animate(){
    requestAnimationFrame(animate);

    updateTilesAroundCamera();

    renderer.render(scene,camera);
}
animate();

// ---------------------------------------------------
</script>

</body>
</html>
