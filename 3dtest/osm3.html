<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>OSM 3D Buildings + Tile Loader</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: rgba(255,255,255,0.8);
    padding: 8px;
    border-radius: 6px;
  }
</style>
</head>
<body>

<div id="ui">
  <button id="loadButton">OSM建物をロード（16タイル）</button>
</div>

<!-- three.js（グローバル版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls（グローバル版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>

// ==============================
// Three.js 初期化
// ==============================
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0c4ff);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);
camera.position.set(0, 200, 200);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(200, 300, 200);
scene.add(sun);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(5000, 5000),
  new THREE.MeshPhongMaterial({ color: 0xdddddd })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// ==============================
// タイル座標 → 経度緯度範囲
// ==============================
function tile2bbox(x, y, z) {
  const n = Math.pow(2, z);
  const lon1 = x / n * 360 - 180;
  const lon2 = (x + 1) / n * 360 - 180;

  const lat1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
  const lat2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;

  return [lon1, lat2, lon2, lat1];
}

// ==============================
// OSM 建物 GeoJSON → THREE.js 3D
// ==============================
function addBuildingFromGeoJSON(json, offsetX=0, offsetZ=0) {
  json.features.forEach(f => {
    if (!f.geometry || f.geometry.type !== "Polygon") return;

    const coords = f.geometry.coordinates[0];
    const shape = new THREE.Shape();

    coords.forEach((c, i) => {
      const px = (c[0] - offsetX) * 10000; 
      const pz = (c[1] - offsetZ) * 10000; 
      if (i === 0) shape.moveTo(px, pz);
      else shape.lineTo(px, pz);
    });

    const h = f.properties.height
      ? parseFloat(f.properties.height)
      : (f.properties["building:levels"] ? f.properties["building:levels"] * 3 : 10);

    const geo = new THREE.ExtrudeGeometry(shape, {
      depth: h,
      bevelEnabled: false
    });

    const mesh = new THREE.Mesh(
      geo,
      new THREE.MeshPhongMaterial({ color: 0x6699ff })
    );

    mesh.rotation.x = -Math.PI / 2;
    mesh.position.y = h / 2;

    scene.add(mesh);
  });
}

// ==============================
// 1タイル読み込み
// ==============================
async function loadTile(z, x, y) {
  const [lon1, lat1, lon2, lat2] = tile2bbox(x, y, z);

  const query = `
    [out:json];
      way["building"](${lat1},${lon1},${lat2},${lon2});
    (._;>;);
    out geom;
  `;

  const url = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query);

  console.log("▶ Overpass:", url);

  const res = await fetch(url);
  if (!res.ok) {
    console.warn("⚠ Overpass エラー:", res.status);
    return;
  }

  const json = await res.json();
  addBuildingFromGeoJSON(json, lon1, lat1);
}

// ==============================
// Z=16 → Z=18 に分割して 16 タイルを読み込む
// ==============================
async function loadTileSplit() {
  const Z = 16;
  const X = 58269; // 渋谷
  const Y = 25805;

  const Z2 = 18;            // 4倍 (16タイル)
  const scale = 1 << (Z2 - Z); // 2^(18-16)=4

  for (let dx = 0; dx < scale; dx++) {
    for (let dy = 0; dy < scale; dy++) {

      const x2 = X * scale + dx;
      const y2 = Y * scale + dy;

      await loadTile(Z2, x2, y2);

      await new Promise(r => setTimeout(r, 300)); // Overpass保護
    }
  }
}

// ==============================
// UI ボタン
// ==============================
document.getElementById("loadButton").onclick = () => {
  loadTileSplit();
};

// ==============================
// Render
// ==============================
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
