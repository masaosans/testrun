<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>OSM 3D Buildings + Multi Tile Loader</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: rgba(255,255,255,0.8);
    padding: 8px;
    border-radius: 6px;
  }
</style>
</head>
<body>

<div id="ui">
  <button id="loadButton">OSM建物をロード（複数タイル）</button>
</div>

<!-- three.js（グローバル版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls（グローバル版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>

// ==============================
// Three.js 初期化
// ==============================
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0c4ff);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
camera.position.set(0, 200, 200);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(200, 300, 200);
scene.add(sun);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(5000, 5000),
  new THREE.MeshPhongMaterial({ color: 0xdddddd })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// ==============================
// タイル座標 → bbox
// ==============================
function tile2bbox(x, y, z) {
  const n = Math.pow(2, z);
  const lon1 = x / n * 360 - 180;
  const lon2 = (x + 1) / n * 360 - 180;

  const lat1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
  const lat2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;

  return [lon1, lat2, lon2, lat1];
}

// ==============================
// 建物 GeoJSON → 3D
// ==============================
function addBuildingFromGeoJSON(json, offsetX=0, offsetZ=0) {
  json.features.forEach(f => {
    if (!f.geometry || f.geometry.type !== "Polygon") return;

    const coords = f.geometry.coordinates[0];
    const shape = new THREE.Shape();

    coords.forEach((c, i) => {
      const px = (c[0] - offsetX) * 10000;
      const pz = (c[1] - offsetZ) * 10000;
      if (i === 0) shape.moveTo(px, pz);
      else shape.lineTo(px, pz);
    });

    const h = f.properties.height
      ? parseFloat(f.properties.height)
      : (f.properties["building:levels"] ? f.properties["building:levels"] * 3 : 10);

    const geo = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
    const mat = new THREE.MeshPhongMaterial({ color: 0x6699ff });
    const mesh = new THREE.Mesh(geo, mat);

    mesh.rotation.x = -Math.PI / 2;
    mesh.position.y = h / 2;

    scene.add(mesh);
  });
}

// ==============================
// Overpass: 小タイル単位でロード
// ==============================
async function loadTile(z, x, y) {
  const [lon1, lat1, lon2, lat2] = tile2bbox(x, y, z);

  const url =
    "https://overpass-api.de/api/interpreter?data=" +
    encodeURIComponent(`
      [out:json];
      (
        way["building"](${lat1},${lon1},${lat2},${lon2});
      );
      (._;>;);
      out geom;
    `);

  console.log("➡ fetch:", url);

  const res = await fetch(url);
  if (!res.ok) {
    console.warn("❌ fetch failed", url);
    return;
  }

  const data = await res.json();
  addBuildingFromGeoJSON(data, lon1, lat1);
}

// ==============================
// ■指定タイル(Z=16) → 下位タイル(Z=18)に分割して大量取得
// ==============================
async function loadSubTiles() {
  const Z_BASE = 16;
  const X = 58269;  // 渋谷付近
  const Y = 25805;

  const Z_SUB = 18;  // ← 4倍拡大（1タイル → 16タイル）
  const DIFF = Math.pow(2, Z_SUB - Z_BASE);  // =4

  for (let dx = 0; dx < DIFF; dx++) {
    for (let dy = 0; dy < DIFF; dy++) {
      const x2 = X * DIFF + dx;
      const y2 = Y * DIFF + dy;

      console.log(`Loading sub tile: z=${Z_SUB} x=${x2} y=${y2}`);

      await loadTile(Z_SUB, x2, y2);

      await new Promise(r => setTimeout(r, 300)); // API負荷軽減
    }
  }
}

// ==============================
// UI
// ==============================
document.getElementById("loadButton").onclick = () => {
  loadSubTiles();
};

// ==============================
// Render loop
// ==============================
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
