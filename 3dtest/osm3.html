<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>OSM 3D Buildings + Tile Loader</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: rgba(255,255,255,0.8);
    padding: 8px;
    border-radius: 6px;
  }
</style>
</head>
<body>

<div id="ui">
  <button id="loadButton">OSM建物をロード</button>
</div>

<!-- three.js（グローバル版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls（グローバル版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>

// ==============================
// ■ Three.js 初期化
// ==============================
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0c4ff);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);
camera.position.set(0, 200, 200);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(200, 300, 200);
scene.add(sun);

// Ground plane
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(5000, 5000),
  new THREE.MeshPhongMaterial({ color: 0xdddddd })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// ==============================
// ■ タイル座標 → 経度緯度範囲 変換
// ==============================
function tile2bbox(x, y, z) {
  const n = Math.pow(2, z);
  const lon1 = x / n * 360 - 180;
  const lon2 = (x + 1) / n * 360 - 180;

  const lat1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
  const lat2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;

  return [lon1, lat2, lon2, lat1];
}

// ==============================
// ■ OSM Building GeoJSON → THREE Buildings
// ==============================
function addBuildingFromGeoJSON(json, offsetX=0, offsetZ=0) {
  json.features.forEach(f => {
    if (!f.geometry || f.geometry.type !== "Polygon") return;

    const coords = f.geometry.coordinates[0];

    // Shape を作る
    const shape = new THREE.Shape();
    coords.forEach((c, i) => {
      const px = (c[0] - offsetX) * 10000; // 拡大スケール
      const pz = (c[1] - offsetZ) * 10000;
      if (i === 0) shape.moveTo(px, pz);
      else shape.lineTo(px, pz);
    });

    // 高さの決定
    const h = f.properties.height
      ? parseFloat(f.properties.height)
      : (f.properties["building:levels"] ? f.properties["building:levels"] * 3 : 10);

    // Extrude
    const geo = new THREE.ExtrudeGeometry(shape, {
      depth: h,
      bevelEnabled: false
    });
    const mat = new THREE.MeshPhongMaterial({ color: 0x6699ff });
    const mesh = new THREE.Mesh(geo, mat);

    mesh.rotation.x = -Math.PI / 2; // Z-up → Y-up
    mesh.position.y = h / 2;

    scene.add(mesh);
  });
}

// ==============================
// ■ タイルロード (簡易版：1タイルだけ読み込み)
// ==============================
async function loadTile(z, x, y) {
  const [lon1, lat1, lon2, lat2] = tile2bbox(x, y, z);

  const url =
    "https://overpass-api.de/api/interpreter?data=" +
    encodeURIComponent(`
      [out:json];
      (
        way["building"](${lat1},${lon1},${lat2},${lon2});
      );
      (._;>;);
      out geom;
    `);

  console.log("Request:", url);
  const res = await fetch(url);
  const data = await res.json();

  addBuildingFromGeoJSON(data, lon1, lat1);
}

// ==============================
// ■ UI ボタン
// ==============================
document.getElementById("loadButton").onclick = () => {
  // 渋谷区付近のタイル例
  const z = 16;
  const x = 58269;
  const y = 25805;

  loadTile(z, x, y);
};

// ==============================
// ■ Render loop
// ==============================
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
