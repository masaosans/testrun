<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>3D City Walk - OSM + Height + Texture</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
#info {
  position:fixed; top:8px; left:8px; background:rgba(255,255,255,0.8);
  padding:6px 8px; border-radius:6px; font-family:sans-serif; font-size:13px;
}
</style>
</head>
<body>
<div id="info">WASD / スマホジョイスティックで移動</div>

<script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
// ----------------------------
// Three.js 基本セットアップ
// ----------------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// 光
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(50, 100, 50);
dir.castShadow = true;
scene.add(dir);
const amb = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(amb);

// 地面
const groundMat = new THREE.MeshStandardMaterial({ color:0x7cfc00 });
const groundGeo = new THREE.PlaneGeometry(1000,1000);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// ----------------------------
// キャラクター
// ----------------------------
const playerHeight = 1.8;
const playerGeo = new THREE.BoxGeometry(0.8, playerHeight, 0.8);
const playerMat = new THREE.MeshStandardMaterial({ color:0x0077ff });
const player = new THREE.Mesh(playerGeo, playerMat);
player.position.set(0, playerHeight/2, 0);
player.castShadow = true;
scene.add(player);

// TPSカメラ
const camOffset = new THREE.Vector3(0,5,-10);
function updateCamera(){
    const offset = camOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    camera.position.copy(player.position).add(offset);
    camera.lookAt(player.position);
}

// ----------------------------
// 建物データロード（Overpass API）
// ----------------------------
const bbox = [35.677,139.764,35.683,139.770]; // 東京駅周辺
const query = `
[out:json][timeout:25];
(
  way["building"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
);
out body;
>;
out skel qt;
`;

fetch('https://overpass-api.de/api/interpreter', {
    method:'POST',
    body: query
})
.then(res=>res.json())
.then(data=>{
    const nodes = {};
    data.elements.forEach(e=>{ if(e.type==="node") nodes[e.id]=e; });

    const buildings = [];
    data.elements.forEach(e=>{
        if(e.type==="way" && e.tags && e.tags.building){
            const coords = e.nodes.map(id=>{
                const n = nodes[id];
                return [(n.lon-bbox[1])*111000, (n.lat-bbox[0])*111000];
            });

            // 高さ取得（height > building:levels*3 > default 20）
            let height = 20; // default
            if(e.tags.height){
                const h = parseFloat(e.tags.height.replace('m',''));
                if(!isNaN(h)) height = h;
            } else if(e.tags['building:levels']){
                const lv = parseFloat(e.tags['building:levels']);
                if(!isNaN(lv)) height = lv*3;
            }

            buildings.push({coords, height});
        }
    });

    // テクスチャ作成（簡易窓）
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle="#8888aa"; ctx.fillRect(0,0,64,64);
    ctx.fillStyle="#222222";
    for(let y=2;y<64;y+=8){
        for(let x=2;x<64;x+=8){
            ctx.fillRect(x,y,4,4);
        }
    }
    const tex = new THREE.CanvasTexture(canvas);

    // Three.js に建物追加
    const buildingMeshes = [];
    buildings.forEach(b=>{
        const shape = new THREE.Shape();
        b.coords.forEach((p,i)=>{
            if(i===0) shape.moveTo(p[0], p[1]);
            else shape.lineTo(p[0], p[1]);
        });
        const extrudeSettings = { depth: b.height, bevelEnabled:false };
        const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const mat = new THREE.MeshStandardMaterial({ map: tex });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = 0;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        buildingMeshes.push(mesh);
    });

    window.buildingMeshes = buildingMeshes;
});

// ----------------------------
// 操作
// ----------------------------
const keys = {};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

let joyX=0, joyY=0;
nipplejs.create({
    zone:document.body, mode:'static', position:{left:80,bottom:80}, color:'gray', size:100
}).on('move',(evt,data)=>{ joyX=data.vector.x; joyY=-data.vector.y; })
  .on('end',()=>{ joyX=0; joyY=0; });

// ----------------------------
// 衝突判定
function willCollide(nextPos){
    if(!window.buildingMeshes) return false;
    const halfY = playerHeight/2;
    const tmpBB = new THREE.Box3(
        new THREE.Vector3(nextPos.x-0.4, nextPos.y-halfY, nextPos.z-0.4),
        new THREE.Vector3(nextPos.x+0.4, nextPos.y+halfY, nextPos.z+0.4)
    );
    for(let i=0;i<window.buildingMeshes.length;i++){
        const bb = new THREE.Box3().setFromObject(window.buildingMeshes[i]);
        if(tmpBB.intersectsBox(bb)) return true;
    }
    return false;
}

// ----------------------------
// アニメーションループ
// ----------------------------
const clock = new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());

    let mvX=0, mvZ=0;
    if(keys['w']||keys['arrowup']) mvZ -= 1;
    if(keys['s']||keys['arrowdown']) mvZ += 1;
    if(keys['a']||keys['arrowleft']) mvX -= 1;
    if(keys['d']||keys['arrowright']) mvX += 1;
    mvX += joyX; mvZ += joyY;

    if(Math.hypot(mvX,mvZ)>0.001){
        const nx = mvX/Math.hypot(mvX,mvZ);
        const nz = mvZ/Math.hypot(mvX,mvZ);
        const angle = Math.atan2(nx,nz);
        player.rotation.y = angle;
        const next = player.position.clone();
        const speed = 6;
        next.x += nx*speed*dt;
        next.z += nz*speed*dt;
        if(!willCollide(next)) player.position.copy(next);
    }

    updateCamera();
    renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});

</script>
</body>
</html>
