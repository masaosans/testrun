<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>3D City Tile Demo</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
#info {
  position:fixed; top:8px; left:8px; background:rgba(255,255,255,0.8);
  padding:6px 8px; border-radius:6px; font-family:sans-serif; font-size:13px;
}
</style>
</head>
<body>
<div id="info">WASD / スマホジョイスティックで移動</div>

<script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
// ----------------------------
// Three.js 基本セットアップ
// ----------------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 3000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// 光
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(50, 100, 50);
dir.castShadow = true;
scene.add(dir);
const amb = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(amb);

// 地面
const groundMat = new THREE.MeshStandardMaterial({ color:0x7cfc00 });
const groundGeo = new THREE.PlaneGeometry(2000,2000);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// ----------------------------
// キャラクター
// ----------------------------
const playerHeight = 1.8;
const playerGeo = new THREE.BoxGeometry(0.8, playerHeight, 0.8);
const playerMat = new THREE.MeshStandardMaterial({ color:0x0077ff });
const player = new THREE.Mesh(playerGeo, playerMat);
player.position.set(0, playerHeight/2, 0);
player.castShadow = true;
scene.add(player);

// TPSカメラ
const camOffset = new THREE.Vector3(0,5,-10);
function updateCamera(){
    const offset = camOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    camera.position.copy(player.position).add(offset);
    camera.lookAt(player.position);
}

// ----------------------------
// 簡易窓テクスチャ
// ----------------------------
const canvas = document.createElement('canvas');
canvas.width = canvas.height = 64;
const ctx = canvas.getContext('2d');
ctx.fillStyle="#8888aa"; ctx.fillRect(0,0,64,64);
ctx.fillStyle="#222222";
for(let y=2;y<64;y+=8){
  for(let x=2;x<64;x+=8){
    ctx.fillRect(x,y,4,4);
  }
}
const windowTex = new THREE.CanvasTexture(canvas);

// ----------------------------
// タイルロード関数
// ----------------------------
const buildingMeshes = [];

function fetchTile(lat, lon, tileSize){
  const query = `
[out:json][timeout:25];
(way["building"](${lat},${lon},${lat+tileSize},${lon+tileSize}););
out body;>;out skel qt;`;

  fetch('https://overpass-api.de/api/interpreter', {
    method:'POST', body:query
  }).then(res=>res.json()).then(data=>{
    const nodes = {};
    data.elements.forEach(e=>{ if(e.type==="node") nodes[e.id]=e; });

    data.elements.forEach(e=>{
      if(e.type==="way" && e.tags && e.tags.building){
        const coords = e.nodes.map(id=>{
          const n = nodes[id];
          return [(n.lon-lon)*111000, (n.lat-lat)*111000];
        });

        let height = 20;
        if(e.tags.height){
          const h = parseFloat(e.tags.height.replace('m',''));
          if(!isNaN(h)) height = h;
        } else if(e.tags['building:levels']){
          const lv = parseFloat(e.tags['building:levels']);
          if(!isNaN(lv)) height = lv*3;
        }

        const shape = new THREE.Shape();
        coords.forEach((p,i)=>{ if(i===0) shape.moveTo(p[0],p[1]); else shape.lineTo(p[0],p[1]); });
        const geo = new THREE.ExtrudeGeometry(shape,{depth:height, bevelEnabled:false});
        const mat = new THREE.MeshStandardMaterial({ map: windowTex });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = 0;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        buildingMeshes.push(mesh);
      }
    });
  });
}

// ----------------------------
// タイルを複数ロード（東京駅周辺 3x3 タイル 約600m四方）
const tileSize = 0.002;
const baseLat = 35.677;
const baseLon = 139.764;
for(let i=0;i<3;i++){
  for(let j=0;j<3;j++){
    fetchTile(baseLat+i*tileSize, baseLon+j*tileSize, tileSize);
  }
}

// ----------------------------
// 操作
// ----------------------------
const keys = {};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

let joyX=0, joyY=0;
nipplejs.create({
  zone:document.body, mode:'static', position:{left:80,bottom:80}, color:'gray', size:100
}).on('move',(evt,data)=>{ joyX=data.vector.x; joyY=-data.vector.y; })
  .on('end',()=>{ joyX=0; joyY=0; });

// ----------------------------
// 衝突判定
function willCollide(nextPos){
  const halfY = playerHeight/2;
  const tmpBB = new THREE.Box3(
    new THREE.Vector3(nextPos.x-0.4, nextPos.y-halfY, nextPos.z-0.4),
    new THREE.Vector3(nextPos.x+0.4, nextPos.y+halfY, nextPos.z+0.4)
  );
  for(let i=0;i<buildingMeshes.length;i++){
    const bb = new THREE.Box3().setFromObject(buildingMeshes[i]);
    if(tmpBB.intersectsBox(bb)) return true;
  }
  return false;
}

// ----------------------------
// アニメーションループ
// ----------------------------
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());

  let mvX=0, mvZ=0;
  if(keys['w']||keys['arrowup']) mvZ -= 1;
  if(keys['s']||keys['arrowdown']) mvZ += 1;
  if(keys['a']||keys['arrowleft']) mvX -= 1;
  if(keys['d']||keys['arrowright']) mvX += 1;
  mvX += joyX; mvZ += joyY;

  if(Math.hypot(mvX,mvZ)>0.001){
    const nx = mvX/Math.hypot(mvX,mvZ);
    const nz = mvZ/Math.hypot(mvX,mvZ);
    const angle = Math.atan2(nx,nz);
    player.rotation.y = angle;
    const next = player.position.clone();
    const speed = 6;
    next.x += nx*speed*dt;
    next.z += nz*speed*dt;
    if(!willCollide(next)) player.position.copy(next);
  }

  updateCamera();
  renderer.render(scene,camera);
}
animate();

// ----------------------------
// リサイズ対応
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
